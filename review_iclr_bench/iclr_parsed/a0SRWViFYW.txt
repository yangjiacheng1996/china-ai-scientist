# STOCHASTIC PROJECTIVE SPLITTING: SOLVING SADDLE-POINT PROBLEMS WITH MULTIPLE REGULARIZERS

**Anonymous authors**
Paper under double-blind review

ABSTRACT

We present a new, stochastic variant of the projective splitting (PS) family of
algorithms for monotone inclusion problems. It can solve min-max and noncooperative game formulations arising in applications such as robust ML without the
convergence issues associated with gradient descent-ascent, the current de facto
standard approach in ML applications. Our proposal is the first version of PS able
to use stochastic gradient oracles. It can solve min-max games while handling
multiple constraints and nonsmooth regularizers via projection and proximal operators. Unlike other stochastic splitting methods that can solve such problems,
our method does not rely on a product-space reformulation of the original problem.
We prove almost-sure convergence of the iterates to the solution and a convergence
rate for the expected residual. By working with monotone inclusions rather than
variational inequalities, our analysis avoids the drawbacks of measuring convergence through the restricted gap function. We close with numerical experiments on
a distributionally robust sparse logistic regression problem.

1 INTRODUCTION

The most prominent application of optimization in ML is empirical risk minimization. However,
inspired by the success of GANs (Goodfellow et al., 2014)., ML practitioners have developed more
complicated min-max and adversarial optimization formulations (Yu et al., 2021; Kuhn et al., 2019;
Shafieezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin et al., 2020; Namkoong & Duchi, 2016;
Huang et al., 2017; Wadsworth et al., 2018; Zhang et al., 2018; Edwards & Storkey, 2015; Celis
& Keswani, 2019). Solving these multi-player games leads to issues not seen when minimizing a
single-player loss function. The competitive nature of a game leads to rotational dynamics that can
cause intuitive gradient-based methods to fail to converge (Gidel et al., 2019; Daskalakis et al., 2018;
Hsieh et al., 2020).

A mathematical framework underlying both convex optimization and saddle-point problems is the
_monotone inclusion problem; see Ryu & Boyd (2016) for an introduction. Methods developed_
for monotone inclusions will converge for convex-concave, games as they are explicitly designed
to handle such problems’ governing dynamics. In recent years, monotone inclusion methods and
theory have started to receive attention in the ML community (Diakonikolas, 2020; Liu et al., 2021;
Ryu et al., 2020; Pathak & Wainwright, 2020), with a focus on monotone variational inequalities,
which form a special case of monotone inclusions (Antonakopoulos et al., 2019; Gidel et al., 2019;
Daskalakis et al., 2018; Hsieh et al., 2020; Mertikopoulos et al., 2019).

The most prevalent methods for solving min-max games in ML are variants of gradient descent-ascent
(GDA). This method alternates between a gradient-descent step for the minimizing player and a
gradient-ascent step for the maximizing player. Unfortunately, GDA requires additional assumptions
to converge on convex-concave games, and it even fails for some simple 2D bilinear games (Gidel
et al., 2019, Prop. 1). While there have been several approaches to modify either GDA (Chavdarova
et al., 2021; Grnarova et al., 2021; Balduzzi et al., 2018) or the underlying game objective (Mescheder
et al., 2018; Nagarajan & Kolter, 2017; Mescheder et al., 2017) to ensure convergence, this paper
instead develops a method for solving monotone inclusions that can naturally handle game dynamics.


-----

Our approach builds upon the recently proposed projective splitting (PS) method with forward
steps (Johnstone & Eckstein, 2020b). PS is designed specifically for solving monotone inclusions,
thus does not fall prey to the convergence issues that plague GDA, at least for convex-concave games.
PS is within the general class of projective splitting methods invented by Eckstein & Svaiter (2008)
and developed further in Eckstein & Svaiter (2009); Alotaibi et al. (2014); Combettes & Eckstein
(2018); Eckstein (2017); Johnstone & Eckstein (2019; 2021; 2020a). These methods work by creating
a separating hyperplane between the current iterate and the solution and then moving closer to the
solution by projecting the current iterate onto this hyperplane (see Section 3 for an overview). Other
than being able to natively handle game dynamics, the primary advantage of PS is that it fully splits
problems involving an arbitrary number of regularizers and constraints. “Full splitting” means that the
method can handle multiple regularizers and constraints through their respective individual proximal
and projection operators, along with the smooth terms via gradients. What makes this useful is that
many of the regularizers used in ML have proximal operators that are relatively easy to compute; see
for example Parikh & Boyd (2013).

Despite these advantages, the preexisting PS framework has a significant drawback: it requires
deterministic gradient oracles. This feature makes it impractical for application to large datasets for
which stochastic oracles may be the only feasible option.

**Contributions** The primary contribution of this work is a new projective splitting algorithm that
allows for a stochastic gradient oracle. We call the method stochastic projective splitting (SPS). Our
method “fully splits” the monotone inclusion problem

Find z ∈ R[d] s.t. 0 ∈ [P]i[n]=1 _[A][i][(][z][) +][ B][(][z][)][,]_ (1)

where B is monotone and L-Lipschitz and each Ai is maximal monotone and typically set valued,
usually arising from a constraint or a nonsmooth regularizer in the underlying optimization problem
or game; see for example Ryu & Boyd (2016) for definitions. For some example ML applications
of (1), see Section 2 and Appendix A. Here, an algorithm that “fully splits” (1) means one whose
computational steps each involve only the individual operators A1, . . ., An, B. Ours is the first
method that can accomplish full splitting without a product-space reformulation that recasts (1) as a
two-operator problem on a higher-dimensional space, a tactic whose disadvantages are discussed in
Appendix F.7. Our method interrogates the Lipschitz operator B through a stochastic oracle. Previous
methods splitting (1) have either required a deterministic oracle for B, or have made far more
restrictive assumptions on the noise or the operators (Briceño-Arias & Combettes, 2011; Combettes &
Pesquet, 2012; Malitsky & Tam, 2020; Bot et al., 2019; Van Dung & Vu, 2021) than we will require
below. However, the stochastic methods of Alacaoglu et al. (2021) and Böhm et al. (2020), when
combined with a product-space reformulation, can solve (1) when all the Ai are subdifferentials of
convex functions; see Section 6.

When moving away from a deterministic gradient oracle in projective splitting, a key difficulty is that
the generated hyperplanes do not guarantee separation between the solution and the current point. We
solve this issue by relaxing the projection: we only update each iterate in the direction of the noisy
projection and scale its movement by a decreasing stepsize that allows for control of the stochastic
error. Using the framework of stochastic quasi-Fejér monotonicity (Combettes & Pesquet, 2015),
we prove almost-sure convergence of the final iterate and do not require averaging of the iterates
(Theorem 1, Section 5). We also provide a non-asymptotic convergence rate for the approximation
residual (Theorem 2, Section 5).

A special case of SPS is the recently-developed Double Stepsize Extragradient Method (DSEG) (Hsieh
et al., 2020). When n = 0 and therefore only B is present in (1), DSEG and SPS coincide. Thus, our
method extends DSEG to allow for regularizers and constraints. Our analysis also provides a new
interpretation for DSEG as a special case of projective splitting. Our nonasymptotic convergence rate
for SPS also applies to DSEG under no additional assumptions. By contrast, the original convergence
rate analysis for DSEG requires either strong monotonicity or an error bound.

We close with numerical experiments on a distributionally robust sparse logistic regression problem.
This is a nonsmooth convex-concave min-max problem which can be converted to (1) with n = 2
set-valued operators. On this problems class, SPS compares well to the possible alternative splitting
methods.


-----

**Non-monotone problems** The work of Hsieh et al. (2020) included a local convergence analysis
for DSEG applied to locally monotone problems. For min-max problems, if the objective is locally
convex-concave at a solution and DSEG is initialized in close proximity, then for small enough
stepsizes it converges to the solution with high probability. It is possible to extend this result to SPS,
along with our convergence rate analysis. This result is beyond the scope of this work, but Appendix
J provides a proof sketch.

2 BACKGROUND ON MONOTONE INCLUSIONS

Since they are so important to SPS, this section provides some background material regarding monotone inclusions, along with their connections to convex optimization, games, and ML. Appendix G
discusses their connections to variational inequalities. For a more thorough treatment, we refer
to Bauschke & Combettes (2017). See Appendix A for a longer discussion of the applications of
monotone inclusions to ML along with several examples.

**Fundamentals** Let f : R[d] _→_ R ∪{∞} be closed, convex, and proper (CCP). Recall that its
_subdifferential ∂f is given by ∂f_ (x) =[.] _{g : f_ (y) ≥ _f_ (x) + g[⊤](y − _x)}. The map ∂f has the_
property
_u ∈_ _∂f_ (x), v ∈ _∂f_ (y) =⇒ (u − _v)⊤(x −_ _y) ≥_ 0,
and any point-to-set map having this property is called a monotone operator. A monotone operator
_T is called maximal if no additional points can be included in the image T_ (x) of any x ∈ R[d]
without violating the above property (Bauschke & Combettes, 2017, Def. 20.20). Subgradient maps
of CCP functions are maximal (Bauschke & Combettes, 2017, Thm. 20.25). A minimizer of f is
any x[∗] such that 0 ∈ _∂f_ (x[∗]). This is perhaps the simplest example of a monotone inclusion, the
problem of finding x such that 0 ∈ _T_ (x), where T is a monotone operator. If f is smooth, then
_∂f_ (x) = {∇f (x)} for all x, and the monotone inclusion 0 ∈ _∂f_ (x) is equivalent to the first-order
optimality condition 0 = ∇f (x).

Under certain regularity conditions (Bauschke & Combettes, 2017, Cor. 16.5), minimizing a sum of
CCP functions f1, . . ., fn is equivalent to solving the monotone inclusion formed from the sum of
their subdifferentials:

_n_ _n_

_x[∗]_ arg min _fi(x)_ 0 _∂fi(x[∗])._ (2)
_∈_ _x∈R[d]_ _i=1_ _⇐⇒_ _∈_ _i=1_

X X

As throughout this paper for all set addition operations, the summation on the right-hand side of (2)
is the Minkowski sum _i=1_ _[S][i][ =][ {][P]i[n]=1_ _[s][i][ |][ s][i][ ∈]_ _[S][i][ ∀]_ _[i][ ∈]_ [1][..n][}][. For a convex set][ X][, a constraint]
_x ∈_ _C for some convex set C may be imposed by setting one of the fi to be the indicator function ιC_,
defined by ιC(x) = 0 for x _C and ιC(x) = +_ for x _C. Indicator functions of closed convex_

[P][n] _∈_ _∞_ _̸∈_
sets are CCP (Bauschke & Combettes, 2017, Ex. 1.25), and the subgradient map of ιC is also referred
to as the normal cone map NC of C (Bauschke & Combettes, 2017, Def. 6.37). Multiple constraints
may be imposed by including multiple indicator functions in (2).

**ML applications** The form (2) can be used to model ML problems with multiple constraints and/or
nonsmooth regularizers, including sparse and overlapping group lasso (Jacob et al., 2009), sparse and
low-rank matrix estimation problems (Richard et al., 2012), and rare feature selection (Yan & Bien,
2020); see Pedregosa & Gidel (2018) for an overview.

**Games** Consider a two-player noncooperative game in which each player tries to selfishly minimize
its own loss, with each loss depending on the actions of both players. Typically, the goal is to find a
Nash equilibrium, in which neither player can improve its loss by changing strategy:
_x[∗]_ _∈_ arg minx∈Θ _F_ (x, y[∗]) and _y[∗]_ _∈_ arg miny∈Ω _G(x[∗], y)._ (3)

Assuming that the admissible strategy sets Θ ⊆ R[d][x] and Ω _⊆_ R[d][y] are closed and convex and that
_F and G are differentiable, then writing the first-order necessary conditions for each optimization_
problem in (3) yields


0 _∇xF_ (x[∗], y[∗])
_∈_ _yG(x[∗], y[∗])_
 _∇_


_NΘ(x[∗])_ _NΩ(y[∗])_ _._ (4)
_×_



-----

If G = −F, then (3) is a min-max game. If F is also convex in x and concave in y, then B : (x, y) 7→
(∇xF (x, y), −∇yF (x, y))[⊤] is monotone[1] on R[d][x][+][d][y] (Rockafellar, 1970). In many applications, B
is also Lipschitz continuous. In this situation, (4) is a monotone inclusion involving two operators
_B and NΘ×Ω, with B being Lipschitz. Using the simultaneous version of GDA on (3) is equivalent_
to applying the forward-backward method (FB) (Bauschke & Combettes, 2017, Thm. 26.14) to (4).
However, convergence of FB requires that the operator B be cocoercive (Bauschke & Combettes,
2017, Def. 4.10), and not merely Lipschitz (Bauschke & Combettes, 2017, Thm. 26.14). Thus,
simultaneous GDA fails to converge for (3) without additional assumptions; see Gidel et al. (2019,
Prop. 1) for a simple counterexample.

Regularizers and further constraints may be imposed by adding more operators to (4). For example,
if one wished to apply a (nonsmooth) convex regularizer r : R[d][x] _→_ R ∪{+∞} to the x variables
and a similar regularizer d : R[d][y] _→_ R ∪{+∞} to the y variables, one would add the operator
_A2 : (x, y) 7→_ _∂r(x) × ∂d(y) to the right-hand side of (4)._

**ML applications of games** Distributionally robust supervised learning (DRSL) is an emerging
framework for improving the stability and reliability of ML models in the face of distributional
shifts (Yu et al., 2021; Kuhn et al., 2019; Shafieezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin
et al., 2020; Namkoong & Duchi, 2016). Common approaches to DRSL formulate the problem as
a min-max game between a learner selecting the model parameters and an adversary selecting a
worst-case distribution subject to some ambiguity set around the observed empirical distribution.
This min-max problem is often further reduced to either a finite-dimensional saddlepoint problem or
a convex optimization problem.

DRSL is a source of games with multiple constraints/regularizers. One such formulation, based on
Yu et al. (2021), is discussed in the experiments below. The work in Namkoong & Duchi (2016) uses
an ambiguity set based on f -divergences, while Sinha et al. (2018) introduce a Lagrangian relaxation
of the Wasserstein ball. When applied to models utilizing multiple regularizers (Jacob et al., 2009;
Richard et al., 2012; Yan & Bien, 2020), both of these approaches lead to min-max problems with
multiple regularizers.

Other applications of games in ML, although typically nonconvex, include generative adversarial networks (GANs) (Goodfellow et al., 2014; Arjovsky et al., 2017; Loizou et al., 2020; 2021; Mishchenko
et al., 2020), fair classification (Wadsworth et al., 2018; Zhang et al., 2018; Edwards & Storkey, 2015;
Celis & Keswani, 2019), and adversarial privacy (Huang et al., 2017).

**Resolvents, proximal operators, and projections** A fundamental computational primitive for
solving monotone inclusions is the resolvent. The resolvent of a monotone operator A is defined to
be JA = ([.] _I + A)[−][1], where I is the identity operator and the inverse of any operator T is simply_
_T_ _[−][1]_ : x 7→{y : Ty ∋ _x}. If A is maximal monotone, then for any ρ > 0, JρA is single valued,_
nonexpansive, and has domain equal to R[d] (Bauschke & Combettes, 2017, Thm. 21.1 and Prop.
23.8). Resolvents generalize proximal operators of convex functions: the proximal operator of a CCP
function f is

proxρf (t) = arg min[.] _ρf_ (x) + (1/2) _x_ _t_ _._
_x∈R[d]_ _∥_ _−_ _∥[2]_



It is easily proved that proxρf = Jρ∂f . Like proximal operators, resolvents generalize projection
onto convex sets: if f = ιC, then JρNC = proxρf = projC for any ρ > 0. In many ML applications,
proximal operators, and hence resolvents, are relatively straightforward to compute. For examples,
see Parikh & Boyd (2013, Sec. 6).

**Operator splitting methods** _Operator splitting methods attempt to solve monotone inclusions such_
as (1) by a sequence of operations that each involve only one of the operators A1, . . ., An, B. Such
methods are often presented in the context of convex optimization problems like (2), but typically
apply more generally to monotone inclusions such as (1). In the specific context of (1), each iteration
of such a method ideally handles each Ai via its resolvent and the Lipschitz operator B by explicit
(not stochastic) evaluation. This is a feasible approach if the original problem can be decomposed in

1Sufficient conditions for the monotonicity of (4) in the case where G ̸= −F are discussed in e.g. Scutari
et al. (2014); Briceño-Arias & Combettes (2013).


-----

such a way that the resolvents of each Ai are relatively inexpensive to compute, and full evaluations
of B are possible. Although not discussed here, more general formulations in which matrices couple
the arguments of the operators can broaden the applicability of operator splitting methods.

3 THE PROJECTIVE SPLITTING FRAMEWORK

Before introducing our proposed method, we give a brief introduction to the projective splitting class
of methods.

**The extended solution set** Projective splitting is a primal-dual framework and operates in an
extended space of primal and dual variables. Rather than directly finding a solution to (1), we find a
point in the extended solution set (or Kuhn-Tucker set)

_S_ =[.] (z, w1, . . ., wn+1) _wi ∈_ _Ai(z) ∀_ _i ∈_ 1..n, wn+1 = B(z), _i=1_ _[w][i][ = 0]_ _._ (5)
n o

Given p[∗] = (z[∗], w1[∗] _[. . ., w]n[∗]+1[)][ ∈S][, it is straightforward to see that][ z][∗]_ [solves][ (1)][. Conversely, given]

[P][n][+1]

a solution z[∗] to (1), there must exist w1[∗][, . . ., w]n[∗]+1 [such that][ (][z][∗][, w]1[∗][, . . ., w]n[∗]+1[)][ ∈S][. Suppose]
_p[∗]_ = (z[∗], w1[∗] _[. . ., w]n[∗]+1[)][ ∈S][. Since][ z][∗]_ [solves][ (1)][,][ z][∗] [is typically referred to as a][ primal solution][.]
The vectors w1[∗][, . . ., w]n[∗]+1 [solve a dual inclusion not described here, and are therefore called a][ dual]
_solution. It can be shown that S is closed and convex; see for example Johnstone & Eckstein (2020b)._
We will assume throughout that a solution to (1) exists, therefore the set S is nonempty.

**Separator-projection framework** Projective splitting methods are instances of the general
_separator-projection algorithmic framework for locating a member of a closed convex set S within_
a linear space P. Each iteration k of algorithms drawn from this framework operates by finding a
set Hk that separates the current iterate p[k] _∈P from S, meaning that S is entirely in the set and_
_p[k]_ typically is not. One then attempts to “move closer" to by projecting the p[k] onto Hk. In the
_S_
particular case of projective splitting applied to the problem (1) using (5), we select the space P to be

_P_ =[.] (z, w1, . . ., wn+1) ∈ R[(][n][+2)][d] _i=1_ _[w][i][ = 0]_ _,_ (6)
n o

and each separating set Hk to be the half space _p_ _ϕk(p)_ 0 generated by an affine function
_{_ _∈P |_ [P] ≤[n][+1]}
_ϕk : P →_ R. The general intention is to construct ϕk such that ϕk(p[k]) > 0, but ϕk(p[∗]) ≤ 0 for all
_p[∗]_ _∈S. The construction employed for ϕk in the case of (1) and (5) is of the form_

_ϕk(z, w1, . . ., wn+1)_ =[.] _i=1_ _[⟨][z][ −]_ _[x]i[k][, y]i[k]_ _[−]_ _[w][i][⟩]_ (7)

for some points (x[k]i _[, y]i[k][)][ ∈]_ [R][2][d][,][ i][ ∈] [1][..][(][n][ + 1)][, that must be carefully chosen (see below). Any]
function of the form (7) can be shown to be affine when restricted to[P][n][+1] _P. As mentioned above, the_
standard separator-projection algorithm obtains its next iterate p[k][+1] by projecting p[k] onto Hk. This
calculation involves the usual projection step for a half space, namely

_p[k][+1]_ = p[k] _−_ _αk∇ϕk,_ where _αk = ϕk(p[k])/∥∇ϕk∥[2],_ (8)

and the gradientin=1+1 _[y]i[k][, x]1[k]_ _[−] ∇x[¯][k]ϕ, . . ., xk is computed relative ton+1 −_ _x¯[k][]_ where ¯x[k] _P=_, thus resulting inn+11 _ni=1+1_ _[x]i[k][.]_ _p[k][+1]_ _∈P, i.e._ _∇ϕk =_
P P

4 PROPOSED METHOD

The proposed method is given in Algorithm 1 and called Stochastic Projective Splitting (SPS). Unlike
prior versions of projective splitting, SPS does not employ the stepsize αk of (8) that places the next
iterate exactly on the hyperplane given by ϕk(p) = 0. Instead, it simply moves in the direction _ϕk_
_−∇_
with a pre-defined stepsize _αk_ . This fundamental change is required to deal with the stochastic
_{_ _}_
noise on lines 6 and 8. This noise could lead to the usual choice of αk defined in (8) being unstable
and difficult to analyze. In order to guarantee convergence, the parameters αk and ρk must be chosen
to satisfy certain conditions given below. Note that the gradient is calculated with respect to the
subspace P defined in (6); since the algorithm is initialized within P, it remains in P, within which
_ϕk is affine. Collectively, the updates on lines 9-10 are equivalent to p[k][+1]_ = p[k] _−_ _αk∇ϕk, where_
_p[k]_ = (z[k], w1[k][, . . ., w]n[k]+1[)][.]


-----

Note that SPS does not explicitly evaluate ϕk, which is only used in the analysis, but it does keep
track of (x[k]i _[, y]i[k][)][ for][ i][ ∈]_ [1][..][(][n][ + 1)][. The algorithm’s memory requirements scale linearly with the]
number of nonsmooth operators n in the inclusion (1), with the simplest implementation storing
(3n +5)d working-vector elements. This requirement can be reduced to (n +7)d through a technique
discussed in Appendix H. In most applications, n will be small, for example 2 or 3.

**Updating (x[k]i** _[, y]i[k][)]_ The variables (x[k]i _[, y]i[k][)][ are updated on lines 3-8 of Algorithm 1, in which][ e][k]_

and ϵ[k] are R[d]-valued random variables defined on a probability space (Ω, F, P ). For B we use a
new, noisy version of the two-forward-step procedure from Johnstone & Eckstein (2020b). For each
_Ai, i_ 1..n, we use the same resolvent step used in previous projective splitting papers, originating
_∈_
with (Eckstein & Svaiter, 2008). In the case ϵ[k] = e[k] = 0, the selection of the (x[k]i _[, y]i[k][)][ is identical to]_
that proposed by Johnstone & Eckstein (2020b), resulting in the hyperplane _p : ϕk(p) = 0_ strictly
_{_ _}_
separating p[k] from S.

SPS achieves full splitting of (1): each Ai is processed separately using a resolvent and the Lipschitz
term B is processed via a stochastic gradient oracle. When the Ai arise from regularizers or
constraints, as discussed in Section 2, their resolvents can be readily computed so long as their
respective proximal/projection operators have a convenient form.

**Noise assumptions** Let _k_ =[.] _σ(p[1], . . ., p[k]) and_ _k_ =[.] _σ(ϵ[k]). The stochastic estimators for the_
_F_ _E_
gradients, r[k] and yn[k]+1[, are assumed to be unbiased, that is, the noise terms have mean][ 0][ conditioned]
on the past:

E[ϵ[k]|Fk] = 0, E[e[k]|Fk] = 0 _a.s._ (9)

We impose the following mild assumptions on the variance of the noise:

E _∥ϵ[k]∥[2]|Fk_ _≤_ _N1 + N2∥B(z[k])∥[2]_ _a.s._ (10)

E _e[k]_ _k,_ _k_ _N3 + N4_ _B(x[k]n+1[)][∥][2]_ _a.s.,_ (11)
_∥_ _∥[2]|F_ _E_ _≤_ _∥_

where 0 ≤ _N1, N2, N3, N4 < ∞. We do not require_ _e[k]_ and ϵ[k] to be independent of one another.

**Stepsize choices** The stepsizes ρk and αk are assumed to be deterministic. A constant stepsize
choice which attains a non-asymptotic convergence rate will be considered in the next section
(Theorem 2). The stepsize conditions we will impose to guarantee almost-sure convergence (Theorem
1) are
_∞k=1_ _[α][k][ρ][k][ =][ ∞][,]_ _∞k=1_ _[α]k[2]_ _[<][ ∞][,]_ _∞k=1_ _[α][k][ρ]k[2]_ _[<][ ∞][,][ and][ ρ][k][ ≤]_ _[ρ <][ 1][/L.]_ (12)

For example, in the case L = 1, a particular choice which satisfies these constraints is

P P P

_αk = k[−][0][.][5][−][p]_ for 0 < p < 0.5, and ρk = k[−][0][.][5+][t] for p ≤ _t < 0.5p + 0.25._

For simplicity, the stepsizes τ used for the resolvent updates in lines 3-5 are fixed, but they could be
allowed to vary with both i and k so long as they have finite positive lower and upper bounds.

**Algorithm 1: Stochastic Projective Splitting (SPS)**

**Input :p[1]** = (z[1], w1[1][, . . ., w]n[1]+1[)][ s.t.][ P][n]i=1[+1] _[w]i[1]_ [= 0][,][ {][α][k][, ρ][k][}]k[∞]=1[,][ τ >][ 0]

**1 for k = 1, 2, . . . do**

**2** **for i ∈** 1..n do

**3** _t[k]i_ [=][ z][k][ +][ τw]i[k]

**4** _x[k]i_ [=][ J][τA]i [(][t][k]i [)]

**5** _yi[k]_ [=][ τ][ −][1][(][t]i[k] _[−]_ _[x]i[k][)]_

**6** _r[k]_ = B(z[k]) + ϵ[k] // ϵ[k] is unknown noise term

**7** _x[k]n+1_ [=][ z][k][ −] _[ρ][k][(][r][k][ −]_ _[w]n[k]+1[)]_

**8** _yn[k]+1_ [=][ B][(][x]n[k]+1[) +][ e][k] // e[k] is unknown noise term

_n+1_
**9** _z[k][+1]_ = z[k] _−_ _αk_ _i=1_ _[y]i[k]1_ _n+1_

**10** _wi[k][+1]_ = wi[k] _[−]_ _[α][k]P[(][x]i[k]_ _[−]_ _n+1_ _i=1_ _[x]i[k][)]_ _i ∈_ 1..(n + 1)

P


-----

5 MAIN THEORETICAL RESULTS

**Theorem 1. Suppose A1, . . ., An are maximal monotone, B is L-Lipschitz and monotone, and a**
_solution to (1) exists. For Algorithm 1, suppose (9)-(12) hold. Then with probability one it holds that_
_z[k]_ _z[∗], where z[∗]_ _solves (1). Further, with probability one, x[k]i_
_→_ _[→]_ _[z][∗]_ _[for][ i][ = 1][, . . ., n][.]_

**Proof sketch** Theorem 1 is proved in Appendix C, but we provide a brief sketch here. The proof
begins by deriving a simple recursion inspired by the analysis of SGD (Robbins & Monro, 1951).
Since p[k][+1] = p[k] _αk_ _ϕk, a step of projective splitting can be viewed as GD applied to the affine_
_−_ _∇_
hyperplane generator function ϕk. Thus, for any p[∗],
_∈P_
_∥p[k][+1]_ _−_ _p[∗]∥[2]_ = ∥p[k] _−_ _p[∗]∥[2]_ _−_ 2αk⟨∇ϕk, p[k] _−_ _p[∗]⟩_ + αk[2][∥∇][ϕ][k][∥][2]

= ∥p[k] _−_ _p[∗]∥[2]_ _−_ 2αk(ϕk(p[k]) − _ϕk(p[∗])) + αk[2][∥∇][ϕ][k][∥][2][,]_ (13)
where in the second equation we have used that ϕk(p) is affine on . The basic strategy is to show
_P_
that, for any p[∗] _∈S,_
E[∥∇ϕk∥[2]|Fk] ≤ _C1∥p[k]_ _−_ _p[∗]∥[2]_ + C2 _a.s._
for some C1, C2 > 0. This condition allows one to establish stochastic quasi-Fejér monotonicity
(SQFM) (Combettes & Pesquet, 2015, Proposition 2.3) of the iterates to S. One consequence of
SQFM is that with probability one there exists a subsequence vk such that ϕvk (p[v][k] ) − _ϕvk_ (p[∗])
converges to 0. Furthermore, roughly speaking, we show that ϕk(p[k]) _ϕk(p[∗]) provides an upper_
_−_
bound on the following “approximation residual" for SPS:
_Gk_ =[.] _i=1_ _i_ _i_ _i=1_ _i_ _n+1[∥][2][.]_ (14)

_[∥][y][k]_ _[−]_ _[w][k][∥][2][ +][ P][n]_ _[∥][z][k][ −]_ _[x][k][∥][2][ +][ ∥][B][(][z][k][)][ −]_ _[w][k]_
_Gk provides an approximation error for SPS, as formalized in the following lemma:_
**Lemma 1. For SPS, p[P][k]** _[n]= (z[k], w1[k][, . . ., w]n[k]+1[)][ ∈S][ if and only if][ G][k]_ [= 0][.]
Since yi[k] _[∈]_ _[A][i][(][x]i[k][)][ for][ i][ ∈]_ [1][..n][, having][ G][k][ = 0][ implies that][ z][k][ =][ x]i[k][,][ w]i[k] [=][ y]i[k][, and thus]
The reverse direction is proved in Appendix D.wi[k] _[∈]_ _[A][i][(][z][k][)][ for][ i][ ∈]_ [1][..n][. Since][ w]n[k]+1 [=][ B][(][z][k][)][ and][ P]i[n]=1[+1] _[w]i[k]_ [= 0][, it follows that][ z][k][ solves][ (1)][.]

The quantity Gk generalizes the role played by the norm of the gradient in algorithms for smooth
optimization. In particular, in the special case where n = 0 and B(z) = ∇f (z) for some smooth
convex function f, one has Gk = ∥∇f (z[k])∥[2].

Combining the properties of Gk with other results following from SQFM (such as boundedness) will
allow us to derive almost-sure convergence of the iterates to a solution of (1).

**Convergence rate** We can also establish non-asymptotic convergence rates for the approximation
residual Gk:
**Theorem 2. Fix the total iterations K ≥** 1 of Algorithm 1 and set

_∀k = 1, . . ., K : ρk = ρ = min[.]_ _K_ _[−][1][/][4], 1/2L_ _and_ _αk = Cf_ _ρ[2]_ (15)

_for some Cf > 0. Suppose (9)-(11) hold. Thenn_ o

(1/K)[P][K]j=1 [E][[][G][j][] =][ O][(][K] _[−][1][/][4][)]_
_where the constants are given (along with the proof) in Appendix E._

Theorem 2 implies that if we pick an iterate J uniformly at random from 1..K, then the expected
value of GJ is O(K _[−][1][/][4]). As far as we know, this is the first convergence rate for a stochastic full-_
splitting method solving (1) in the general discontinuous (i.e. set-valued) monotone inclusion case,
and it is not clear whether it can be improved, either by a better analysis or a better method. Faster
rates are certainly possible for deterministic methods under various continuity assumptions; Tseng’s
method obtains O(K _[−][1]) rate (Monteiro & Svaiter, 2010) and the accelerated Halpern iteration under_
Lipschitz continuity obtains O(K _[−][2]) rate (Diakonikolas, 2020). While our rate may seem slow, it_
is worth remembering that (1) features n discontinuous operators Ai, so we expect rates at least as
slow as nonsmooth convex optimization, but perhaps worse because (1) is far more general than
convex optimization. For a different error metric, the restricted gap function, in the special case of
variational inequalities, faster rates have been established in Juditsky et al. (2011) and Böhm et al.
(2020). However, it is unclear how to relate the restricted gap function to Gk, so these rates may not
be directly comparable to Theorem 2.


-----

6 RELATED WORK

Arguably the three most popular classes of operator splitting algorithms are forward-backward
splitting (FB) (Combettes & Pesquet, 2011), Douglas-Rachford splitting (DR) (Lions & Mercier,
1979), and Tseng’s method (Tseng, 2000). The extragradient method (EG) is similar to Tseng’s
method, but has more projection steps per iteration and only applies to variational inequalities
(Korpelevich, 1977; Nemirovski, 2004; Li et al., 2021). The popular Alternating Direction Method
of Multipliers (ADMM), in its standard form, is a dual application of DR (Gabay, 1983). The
three-operator splitting method (Davis & Yin, 2017) can only be applied to (1) if B is cocoercive
rather than merely Lipchitz, and thus its usefulness is mostly limited to optimization applications and
not games. FB, DR, and Tseng’s method apply to monotone inclusions involving two operators, with
varying assumptions on one of the operators. It is possible to derive splitting methods for the more
complicated inclusion (1), involving more than two operators, by applying an appropriate 2-operator
splitting method such as Tseng’s method to a product-space reformulation (PSR) (Briceño-Arias &
Combettes, 2011; Combettes & Pesquet, 2012) (for more on PSR, see Appendix F). The recently
developed forward-reflected-backward (FRB) method (Malitsky & Tam, 2020) can be used in the
same way. However, there are several disadvantages to using a PSR, as discussed in Appendix F.7.

By using a PSR, the stochastic methods of Alacaoglu et al. (2021) and Böhm et al. (2020) can be
applied to (1) in the case that each Ai is a subdifferential. Both of these methods are analyzed in terms
of the restricted gap function. This merit function has a drawback compared with our approximation
residual in that it requires one to find a bound for the iterates. However, Alacaoglu et al. (2021) and
Böhm et al. (2020) do not provide such a bound, meaning that their convergence rate results are
somewhat incomplete. We discuss this issue in Appendix G.

Theoretical convergence of the method of Böhm et al. (2020) requires the use of averaging, since
the final iterate does not converge for certain problems (Hsieh et al., 2020). Empirically, averaging
tends to be slow and to destroy regularizer-induced structural properties such as sparsity or low
matrix rank, so its utility is largely theoretical and it is usually avoided in practice. Furthermore,
averaging loses even its theoretical benefits for nonconvex problems, so its use in such cases is rarer
still. Another drawback of the analysis of Böhm et al. (2020) is that, unlike in SPS, the resolvent
(proximal) stepsizes also need to vanish.

The method of Alacaoglu et al. (2021) applies variance reduction techniques to FRB. It only applies
to finite-sum problems and requires the periodic computation of a full batch gradient, making it
somewhat less flexible and scalable than our method. On the other hand, it has an accelerated ergodic
rate for the restricted gap function in the variational inequality setting. We compare the empirical
performance of SPS with Alacaoglu et al. (2021), Böhm et al. (2020), and several deterministic
methods using PSR in the numerical experiments described in Section 7.

Additional related work is discussed in Appendix B.

7 EXPERIMENTS

We now present some numerical results on distributionally robust supervised learning (DRSL)
problems. We follow the approach of Yu et al. (2021), which introduced a min-max formulation of
Wasserstein DRSL. While other approaches reduce the problem to convex optimization, Yu et al.
(2021) reduce it to a finite-dimensional min-max problem amenable to the use of stochastic methods
on large datasets. However, unlike our proposed SPS method, the variance-reduced extragradient
method that Yu et al. (2021) propose cannot handle multiple nonsmooth regularizers or constraints on
the model parameters. Consequently, we consider distributionally robust sparse logistic regression
(DRSLR), a problem class equivalent to that considered in Yu et al. (2021), but with an added ℓ1
regularizer, a standard tool to induce sparsity. See the Appendix I for the full problem definition.

We compared our SPS method to several methods for solving DRSLR for a collection of real datasets
from the LIBSVM repository (Chang & Lin, 2011). We implemented SPS with αk = Cdk[−][0][.][51] and
_ρk = Cdk[−][0][.][25]_ and called it SPS-decay. We also implement SPS with the fixed stepsize given in (15)
and called it SPS-fixed. We compared the method to deterministic projective splitting (Johnstone &
Eckstein, 2020b) and the following methods based on PSR: Tseng’s method (Tseng, 2000; Combettes
& Pesquet, 2012), the forward-reflected-backward (FRB) method (Malitsky & Tam, 2020), the


-----

Figure 1: Approximation residual versus running time for three LIBSVM benchmark datasets,
with the markers at 10-iteration intervals. Left: epsilon, middle: SUSY, right: real-sim. For the
stochastic algorithms (SPS, S-Tseng, and FRB-VR), we plot the median results over 10 trials, with
unit standard deviation horizontal error bars for the running time and the vertical error bars displaying
the min-to-max range of the approximation residual. The code is provided in the supplementary
material.

stochastic Tseng (S-Tseng) method of Böhm et al. (2020), and the variance-reduced stochastic FRB
method (Alacaoglu et al., 2021), abbreviated FRB-VR. The S-Tseng and FRB-VR algorithms appear
to be the only stochastic splitting methods other than SPS applicable to the tested problem class.

Figure 1 show results for three LIBSVM standard datasets: epsilon[2] (m = 4 · 10[5], d = 2000),
_SUSY (Baldi et al., 2014; Dua & Graff, 2017) (m = 2 · 10[6], d = 18), and real-sim[3]_ (m = 72,309,
_d = 20,958)._

To measure the progress of the algorithms, we used the “approximation residual” Rk defined in
Appendix F. As with Gk, having Rk = 0 implies that z[k] solves (1). We use Rk instead of Gk
because it is also possible to compute essentially the same measure of convergence from the iterates
of the other tested algorithms, establishing a fair comparison. Appendix F provides the details of the
derivation of the residual measure for each algorithm, explores the relationship between Rk and Gk,
and provides additional implementation details.

Figure 1 plots the approximation residual versus running time for all seven algorithms under consideration. The computations were performed using Python 3.8.3 and numpy on a 2019 MacBook Pro
with a 2.4GHz 8-core Intel I9 processor and 32GB of RAM . Being a stochastic method, SPS-decay
seems to outperform the deterministic methods at obtaining a medium-accuracy solution quickly. It
also seems to outperform the stochastic PSR-based methods S-Tseng and FRB-VR.

8 CONCLUSIONS AND FUTURE WORK

We have developed and analyzed a stochastic splitting method that can handle min-max problems
with multiple regularizers and constraints. Going forward, this development should make it possible
to incorporate regularizers and constraints into adversarial formulations trained from large datasets.

Recent versions of deterministic projective splitting (Combettes & Eckstein, 2018; Johnstone &
Eckstein, 2020b) allow for asynchronous and incremental operation, meaning that not all operators
need to be activated at every iteration, with some calculations proceeding with stale inputs. Such
characteristics make projective splitting well-suited to distributed implementations. Many of our SPS
results may be extended to allow for these variations, but we leave those extensions to future work.

REFERENCES

Ahmet Alacaoglu, Yura Malitsky, and Volkan Cevher. Forward-reflected-backward method with
variance reduction. Computational Optimization and Applications, 2021. Available online.

[2Original data source http://largescale.ml.tu-berlin.de/instructions/](http://largescale.ml.tu-berlin.de/instructions/)
[3Original data source https://people.cs.umass.edu/~mccallum/data.html](https://people.cs.umass.edu/~mccallum/data.html)


-----

Abdullah Alotaibi, Patrick L Combettes, and Naseer Shahzad. Solving coupled composite monotone inclusions by successive Fejér approximations of their Kuhn-Tucker set. SIAM Journal on
_Optimization, 24(4):2076–2095, 2014._

Kimon Antonakopoulos, Veronica Belmega, and Panayotis Mertikopoulos. An adaptive mirrorprox method for variational inequalities with singular operators. In H. Wallach, H. Larochelle,
A. Beygelzimer, F. d'Alché-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information
_Processing Systems, volume 32. Curran Associates, 2019._

Martin Arjovsky, Soumith Chintala, and Léon Bottou. Wasserstein generative adversarial networks.
In Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on
_Machine Learning, volume 70 of Proceedings of Machine Learning Research, pp. 214–223, 06–11_
Aug 2017.

Pierre Baldi, Peter Sadowski, and Daniel Whiteson. Searching for exotic particles in high-energy
physics with deep learning. Nature communications, 5(1):1–9, 2014.

David Balduzzi, Sebastien Racaniere, James Martens, Jakob Foerster, Karl Tuyls, and Thore Graepel.
The mechanics of n-player differentiable games. In Jennifer Dy and Andreas Krause (eds.),
_Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings_
_of Machine Learning Research, pp. 354–363. PMLR, 10–15 Jul 2018._

Heinz H Bauschke and Patrick L Combettes. Convex analysis and monotone operator theory in
_Hilbert spaces. Springer, 2nd edition, 2017._

Axel Böhm, Michael Sedlmayer, Ernö Robert Csetnek, and Radu Ioan Bo¸t. Two steps at a time —
taking GAN training in stride with Tseng’s method. arXiv preprint arXiv:2006.09033, 2020.

Radu Ioan Bot, Panayotis Mertikopoulos, Mathias Staudigl, and Phan Tu Vuong. Forward-backwardforward methods with variance reduction for stochastic variational inequalities. arXiv preprint
_arXiv:1902.03355, 2019._

Luis M Briceño-Arias and Patrick L Combettes. A monotone+skew splitting model for composite
monotone inclusions in duality. SIAM Journal on Optimization, 21(4):1230–1250, 2011.

Luis M Briceño-Arias and Patrick L Combettes. Monotone operator methods for Nash equilibria
in non-potential games. In Computational and Analytical Mathematics, volume 50 of Springer
_Proceedings in Mathematics and Statistics, pp. 143–159. Springer, 2013._

L Elisa Celis and Vijay Keswani. Improved adversarial learning for fair classification. arXiv preprint
_arXiv:1901.10443, 2019._

Chih-Chung Chang and Chih-Jen Lin. LIBSVM: A library for support vector machines. ACM
_Transactions on Intelligent Systems and Technology, 2:27:1–27:27, 2011. Software available at_
[http://www.csie.ntu.edu.tw/~cjlin/libsvm.](http://www.csie.ntu.edu.tw/~cjlin/libsvm)

Tatjana Chavdarova, Matteo Pagliardini, Sebastian U Stich, François Fleuret, and Martin Jaggi.
Taming GANs with lookahead-minmax. In International Conference on Learning Representations,
[2021. URL https://openreview.net/forum?id=ZW0yXJyNmoG.](https://openreview.net/forum?id=ZW0yXJyNmoG)

Patrick L. Combettes and Jonathan Eckstein. Asynchronous block-iterative primal-dual decomposition
methods for monotone inclusions. Mathematical Programming, 168(1-2):645–672, 2018.

Patrick L Combettes and Jean-Christophe Pesquet. Proximal splitting methods in signal processing.
In H.H. Bauschke, R.S.S. Burachik, P.L. Combettes, V. Elser, D.R. Luke, and H. Wolkowicz (eds.),
_Fixed-Point Algorithms for Inverse Problems in Science and Engineering, pp. 185–212. Springer,_
2011.

Patrick L Combettes and Jean-Christophe Pesquet. Primal-dual splitting algorithm for solving
inclusions with mixtures of composite, Lipschitzian, and parallel-sum type monotone operators.
_Set-Valued and variational analysis, 20(2):307–330, 2012._

Patrick L Combettes and Jean-Christophe Pesquet. Stochastic quasi-Fejér block-coordinate fixed
point iterations with random sweeping. SIAM Journal on Optimization, 25(2):1221–1248, 2015.


-----

Constantinos Daskalakis, Andrew Ilyas, Vasilis Syrgkanis, and Haoyang Zeng. Training GANs
[with optimism. In International Conference on Learning Representations, 2018. URL https:](https://openreview.net/forum?id=SJJySbbAZ)
[//openreview.net/forum?id=SJJySbbAZ.](https://openreview.net/forum?id=SJJySbbAZ)

Damek Davis and Wotao Yin. A three-operator splitting scheme and its optimization applications.
_Set-Valued and Variational Analysis, 25(4):829–858, 2017._

Jelena Diakonikolas. Halpern iteration for near-optimal and parameter-free monotone inclusion and
strong solutions to variational inequalities. In Conference on Learning Theory, pp. 1428–1451.
PMLR, 2020.

[Dheeru Dua and Casey Graff. UCI machine learning repository, 2017. URL http://archive.](http://archive.ics.uci.edu/ml)
[ics.uci.edu/ml.](http://archive.ics.uci.edu/ml)

Jonathan Eckstein. A simplified form of block-iterative operator splitting and an asynchronous
algorithm resembling the multi-block alternating direction method of multipliers. Journal of
_Optimization Theory and Applications, 173(1):155–182, 2017._

Jonathan Eckstein and Benar Fux Svaiter. A family of projective splitting methods for the sum of
two maximal monotone operators. Mathematical Programming, 111(1):173–199, 2008.

Jonathan Eckstein and Benar Fux Svaiter. General projective splitting methods for sums of maximal
monotone operators. SIAM Journal on Control and Optimization, 48(2):787–811, 2009.

Harrison Edwards and Amos Storkey. Censoring representations with an adversary. arXiv preprint
_arXiv:1511.05897, 2015._

Daniel Gabay. Applications of the method of multipliers to variational inequalities. In M. Fortin and
R. Glowinski (eds.), Augmented Lagrangian Methods: Applications to the Solution of Boundary
_Value Problems, chapter IX, pp. 299–340. North-Holland, Amsterdam, 1983._

Gauthier Gidel, Hugo Berard, Gaëtan Vignoud, Pascal Vincent, and Simon Lacoste-Julien. A
variational inequality perspective on generative adversarial networks. In International Confer_[ence on Learning Representations, 2019. URL https://openreview.net/forum?id=](https://openreview.net/forum?id=r1laEnA5Ym)_
[r1laEnA5Ym.](https://openreview.net/forum?id=r1laEnA5Ym)

Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Z. Ghahramani, M. Welling,
C. Cortes, N. Lawrence, and K. Q. Weinberger (eds.), Advances in Neural Information Processing
_Systems, volume 27. Curran Associates, 2014._

Paulina Grnarova, Yannic Kilcher, Kfir Y Levy, Aurelien Lucchi, and Thomas Hofmann. Generative
minimization networks: Training GANs without competition. arXiv preprint arXiv:2103.12685,
2021.

Patrick T Harker and Jong-Shi Pang. Finite-dimensional variational inequality and nonlinear complementarity problems: a survey of theory, algorithms and applications. Mathematical programming,
48(1):161–220, 1990.

Yu-Guan Hsieh, Franck Iutzeler, Jérôme Malick, and Panayotis Mertikopoulos. On the convergence
of single-call stochastic extra-gradient methods. In H. Wallach, H. Larochelle, A. Beygelzimer,
F. d'Alché-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information Processing Systems,
volume 32. Curran Associates, 2019.

Yu-Guan Hsieh, Franck Iutzeler, Jérôme Malick, and Panayotis Mertikopoulos. Explore aggressively, update conservatively: Stochastic extragradient methods with variable stepsize scaling.
In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Advances in Neural
_Information Processing Systems, volume 33, pp. 16223–16234. Curran Associates, 2020._

Chong Huang, Peter Kairouz, Xiao Chen, Lalitha Sankar, and Ram Rajagopal. Context-aware
generative adversarial privacy. Entropy, 19(12):656, 2017.


-----

Laurent Jacob, Guillaume Obozinski, and Jean-Philippe Vert. Group lasso with overlaps and graph
lasso. In Léon Bottou and Michael Littman (eds.), Proceedings of the 26th International Conference
_on Machine Learning, pp. 433–440, Montreal, June 2009. Omnipress._

Patrick R Johnstone and Jonathan Eckstein. Convergence rates for projective splitting. SIAM Journal
_on Optimization, 29(3):1931–1957, 2019._

Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps only requires
continuity. Optimization Letters, 14(1):229–247, 2020a.

Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps. Mathematical
_Programming, 2020b. Published online, to appear in print._

Patrick R Johnstone and Jonathan Eckstein. Single-forward-step projective splitting: exploiting
cocoercivity. Computational Optimization and Applications, 78(1):125–166, 2021.

Anatoli Juditsky, Arkadi Nemirovski, and Claire Tauvel. Solving variational inequalities with
stochastic mirror-prox algorithm. Stochastic Systems, 1(1):17–58, 2011.

GM Korpelevich. Extragradient method for finding saddle points and other problems. Matekon, 13
(4):35–49, 1977.

Daniel Kuhn, Peyman Mohajerin Esfahani, Viet Anh Nguyen, and Soroosh Shafieezadeh-Abadeh.
Wasserstein distributionally robust optimization: Theory and applications in machine learning.
In Serguei Netessine (ed.), Operations Research & Management Science in the Age of Analytics,
Tutorials in Operations Research, pp. 130–166. INFORMS, 2019.

Chris Junchi Li, Yaodong Yu, Nicolas Loizou, Gauthier Gidel, Yi Ma, Nicolas Le Roux, and Michael I
Jordan. On the convergence of stochastic extragradient for bilinear games with restarted iteration
averaging. arXiv preprint arXiv:2107.00464, 2021.

Tianyi Lin, Chi Jin, and Michael Jordan. On gradient descent ascent for nonconvex-concave minimax
problems. In Hal Daumé III and Aarti Singh (eds.), Proceedings of the 37th International
_Conference on Machine Learning, volume 119 of Proceedings of Machine Learning Research, pp._
6083–6093. PMLR, 2020.

Pierre-Louis Lions and Bertrand Mercier. Splitting algorithms for the sum of two nonlinear operators.
_SIAM Journal on Numerical Analysis, 16(6):964–979, 1979._

Mingrui Liu, Hassan Rafique, Qihang Lin, and Tianbao Yang. First-order convergence theory for
weakly-convex-weakly-concave min-max problems. Journal of Machine Learning Research, 22
(169):1–34, 2021.

Nicolas Loizou, Hugo Berard, Alexia Jolicoeur-Martineau, Pascal Vincent, Simon Lacoste-Julien, and
Ioannis Mitliagkas. Stochastic hamiltonian gradient methods for smooth games. In International
_Conference on Machine Learning, pp. 6370–6381. PMLR, 2020._

Nicolas Loizou, Hugo Berard, Gauthier Gidel, Ioannis Mitliagkas, and Simon Lacoste-Julien. Stochastic gradient descent-ascent and consensus optimization for smooth games: Convergence analysis
under expected co-coercivity. arXiv preprint arXiv:2107.00052, 2021.

Yura Malitsky and Matthew K Tam. A forward-backward splitting method for monotone inclusions
without cocoercivity. SIAM Journal on Optimization, 30(2):1451–1472, 2020.

Panayotis Mertikopoulos, Bruno Lecouat, Houssam Zenati, Chuan-Sheng Foo, Vijay Chandrasekhar,
and Georgios Piliouras. Optimistic mirror descent in saddle-point problems: Going the extra([gradient) mile. In International Conference on Learning Representations, 2019. URL https:](https://openreview.net/pdf?id=Bkg8jjC9KQ)
[//openreview.net/pdf?id=Bkg8jjC9KQ.](https://openreview.net/pdf?id=Bkg8jjC9KQ)

Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. The numerics of GANs. In I. Guyon, U. V.
Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in
_Neural Information Processing Systems, volume 30. Curran Associates, 2017._


-----

Lars Mescheder, Andreas Geiger, and Sebastian Nowozin. Which training methods for GANs do
actually converge? In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International
_Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp._
3481–3490. PMLR, 2018.

Konstantin Mishchenko, Dmitry Kovalev, Egor Shulgin, Peter Richtárik, and Yura Malitsky. Revisiting stochastic extragradient. In International Conference on Artificial Intelligence and Statistics,
pp. 4573–4582. PMLR, 2020.

Aryan Mokhtari, Asuman E Ozdaglar, and Sarath Pattathil. Convergence rate of o(1/k) for optimistic
gradient and extragradient methods in smooth convex-concave saddle point problems. SIAM
_Journal on Optimization, 30(4):3230–3251, 2020._

Renato DC Monteiro and Benar Fux Svaiter. On the complexity of the hybrid proximal extragradient
method for the iterates and the ergodic mean. SIAM Journal on Optimization, 20(6):2755–2787,
2010.

Vaishnavh Nagarajan and J. Zico Kolter. Gradient descent GAN optimization is locally stable. In
I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.),
_Advances in Neural Information Processing Systems, volume 30. Curran Associates, 2017._

Hongseok Namkoong and John C Duchi. Stochastic gradient methods for distributionally robust
optimization with f -divergences. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett
(eds.), Advances in Neural Information Processing Systems, volume 29. Curran Associates, 2016.

Arkadi Nemirovski. Prox-method with rate of convergence O(1/t) for variational inequalities with
Lipschitz continuous monotone operators and smooth convex-concave saddle point problems.
_SIAM Journal on Optimization, 15(1):229–251, 2004._

Yurii Nesterov. Dual extrapolation and its applications to solving variational inequalities and related
problems. Mathematical Programming, 109(2):319–344, 2007.

Neal Parikh and Stephen Boyd. Proximal algorithms. Foundations and Trends in Optimization, 1(3):
123–231, 2013.

Reese Pathak and Martin J Wainwright. Fedsplit: an algorithmic framework for fast federated
optimization. In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Ad_vances in Neural Information Processing Systems, volume 33, pp. 7057–7066. Curran Asso-_
[ciates, Inc., 2020. URL https://proceedings.neurips.cc/paper/2020/file/](https://proceedings.neurips.cc/paper/2020/file/4ebd440d99504722d80de606ea8507da-Paper.pdf)
[4ebd440d99504722d80de606ea8507da-Paper.pdf.](https://proceedings.neurips.cc/paper/2020/file/4ebd440d99504722d80de606ea8507da-Paper.pdf)

Fabian Pedregosa and Gauthier Gidel. Adaptive three-operator splitting. In Jennifer Dy and Andreas
Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, volume 80
of Proceedings of Machine Learning Research, pp. 4085–4094. PMLR, 10–15 Jul 2018.

Fabian Pedregosa, Kilian Fatras, and Mattia Casotto. Proximal splitting meets variance reduction. In
Kamalika Chaudhuri and Masashi Sugiyama (eds.), Proceedings of the Twenty-Second Interna_tional Conference on Artificial Intelligence and Statistics, volume 89 of Proceedings of Machine_
_Learning Research, pp. 1–10. PMLR, 16–18 Apr 2019._

Emile Richard, Pierre-Andre Savalle, and Nicolas Vayatis. Estimation of simultaneously sparse and
low rank matrices. In John Langford and Joelle Pineau (eds.), Proceedings of the 29th International
_Conference on Machine Learning, pp. 1351–1358. Omnipress, 2012._

Herbert Robbins and Sutton Monro. A stochastic approximation method. The annals of mathematical
_statistics, pp. 400–407, 1951._

R Tyrrell Rockafellar. Monotone operators associated with saddle-functions and minimax problems.
_Nonlinear functional analysis, 18(part 1):397–407, 1970._

Ernest K Ryu and Stephen Boyd. Primer on monotone operator methods. Appl. Comput. Math, 15(1):
3–43, 2016.


-----

Ernest K. Ryu, Kun Yuan, and Wotao Yin. Ode analysis of stochastic gradient methods with optimism
and anchoring for minimax problems, 2020.

Gesualdo Scutari, Francisco Facchinei, Jong-Shi Pang, and Daniel P Palomar. Real and complex
monotone communication games. IEEE Transactions on Information Theory, 60(7):4197–4231,
2014.

Soroosh Shafieezadeh-Abadeh, Peyman Mohajerin Esfahani, and Daniel Kuhn. Distributionally
robust logistic regression. In Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama,
and Roman Garnett (eds.), Advances in Neural Information Processing Systems, volume 28, pp.
1576–1584. Curran Associates, 2015.

Aman Sinha, Hongseok Namkoong, and John Duchi. Certifying some distributional robustness with
principled adversarial training. In International Conference on Learning Representations, 2018.
[URL https://openreview.net/forum?id=Hk6kPgZA-.](https://openreview.net/forum?id=Hk6kPgZA-)

Paul Tseng. A modified forward-backward splitting method for maximal monotone mappings. SIAM
_Journal on Control and Optimization, 38(2):431–446, 2000._

Nguyen Van Dung and Bang Cong Vu. Convergence analysis of the stochastic reflected forwardbackward splitting algorithm. arXiv preprint arXiv:2102.08906, 2021.

Christina Wadsworth, Francesca Vera, and Chris Piech. Achieving fairness through adversarial
learning: an application to recidivism prediction. arXiv preprint arXiv:1807.00199, 2018.

Xiaohan Yan and Jacob Bien. Rare feature selection in high dimensions. Journal of the American
_Statistical Association, 2020. Published online, to appear in print._

Yaodong Yu, Tianyi Lin, Eric Mazumdar, and Michael I Jordan. Fast distributionally robust learning
with variance reduced min-max optimization. arXiv preprint arXiv:2104.13326, 2021.

Alp Yurtsever, Bang Cong Vu, and Volkan Cevher. Stochastic three-composite convex minimization.
In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in Neural
_Information Processing Systems, volume 29. Curran Associates, 2016._

Brian Hu Zhang, Blake Lemoine, and Margaret Mitchell. Mitigating unwanted biases with adversarial
learning. In Proceedings of the 2018 AAAI/ACM Conference on AI, Ethics, and Society, pp. 335–
340, 2018.

A ML APPLICATIONS OF THE MONOTONE INCLUSION (1)

There are two main classes of applications of (1) in ML: optimization problems and saddle-point
games.

**Optimization Problems** In this case the monotone inclusion arises from finding the zero of a
sum of subgradients of convex functions, as discussed in Section 2. It is typical in ML to solve the
empirical risk minimization problem


_ri(x)_ (16)
_i=1_

X


min
_x∈R[d]_


_fj(x) +_
_j=1_

X


over a size-m dataset. Usually, the gradient of the loss function fj for each datapoint j is Lipschitz
continuous. The terms ri may be regularizers used to reduce overfitting or encourage structural
properties such as sparsity or low matrix rank. They also may represent constraints on the parameters
such as nonnegativity or the being in the probability simplex. Crucially, these regularizers are rarely
differentiable. The first-order necessary condition for the solution of (16) is


0 ∈∇f (x[∗]) +


_∂ri(x[∗]),_ (17)
_i=1_

X


-----

where f (x) =[.] _m[1]_ _mj=1_ _[f][j][(][x][)][, thus][ ∇][f]_ [(][x][)][ .]= _m[1]_ _mj=1_

of (1), and our method may use the standard stochastic oracle for[∇][f][j][(][x][)][. The inclusion]f (x), namely[ (17)][ is a special case]

P P _∇_


_fj(z)_
_∇_
_jX∈B_


_|B|_


which subsamples a randomly selected minibatch of datapoints B ∈{1, . . ., m}.

**Games** Consider the following nonsmooth Nash equilibrium problem

_n1_ _n2_

_x[∗]_ arg min _F_ (x, y[∗]) + _ri(x)_ and _y[∗]_ arg min _G(x[∗], y) +_ _di(y)._ (18)
_∈_ _x∈R[dx]_ _i=1_ _∈_ _y∈R[dy]_ _i=1_

X X

The terms _i=1_ _[r][i][(][x][)][ and][ P]i[n]=1[2]_ _[d][i][(][y][)][ once again represent regularizers and constraints on each]_
player’s strategy. Note that min-max (saddle-point) problems correspond to having F (x, y) =
_G(x, y). Under appropriate convexity conditions and constraint qualifications, the solutions of (18)_
_−_ [P][n][1]
correspond to the solutions of the following monotone inclusion in the form of (1):


max{n1,n2}

_i=1_

X


0 _∇xF_ (x[∗], y[∗])
_∈_ _yG(x[∗], y[∗])_
 _∇_


_∂ri(x[∗])_ _∂di(y[∗])_ (19)
_×_



where for i > min{n1, n2} we include “dummy functions", either ri(x) = 0 when n1 < n2 or
_di(y) = 0 when n1 < n2. If the functions F and G arise as averages in the same we as f in (16),_
then our method may again use a stochastic oracle for them.

**Distributionally-Robust ML** One example application of (19) is distributionally-robust ML, as
demonstrated in the numerical experiment in Section 7. The full problem statement is given in
Appendix I.

**Lagrangian Duality** Another application of (19) is constrained optimization via Lagrangian duality.
Consider


s.t. _hj(x)_ 0 _j = 1, . . ., p._
_≤_


min
_x∈R[d]_


_f_ (x) +


_ri(x)_
_i=1_

X


As in (16), f is a loss function and the ri may represent regularizers and (“simple”) constraints;
in addition, there are p functional constraints on the model parameters x. Introducing Lagrange
multipliers γ ∈ R[p], the problem can be written as


min _ri(x) +_ _γjhj(x)_
_x∈R[d][ max]γ∈R[p]+_ _i=1_ _j=1_

 X X 

Under appropriate convexity conditions and constraint-qualifications, this reduces to the following

[f] [(][x][) +]  _[.]_

inclusion in the form of (1):

_f_ (x) + _pj=1_ _[γ][j][∇][h][j][(][x][)]_ _n_
0 _∇_ + _∂ri(x[∗])_ 0
_∈_ _h(x)_ _× {_ _}_
 _−_  _i=1_
P X   

where h(x) = [h1(x), h2(x), . . ., hp(x)][⊤]. For certain choices of h, such as linear or quadratic
functions, the first term above is monotone and (locally) Lipschitz continuous (Alacaoglu et al.,
2021).

**Bilinear Games with Many Constraints** Finally, consider the bilinear saddlepoint problem subject
to multiple constraints:

min s.t. _x_ _j_ _j = 1, . . ., n1,_
_x_ R[d][ max]y R[d][ x][⊤][Dy] _∈C[1]_
_∈_ _∈_

_y_ _j_ _j = 1, . . ., n2._
_∈C[2]_


-----

Under some regularity conditions, this problem reduces to the inclusion


max{n1,n2}

_j=1_

X


_Dy[∗]_
0
_∈_ _D[⊤]x[∗]_
 _−_


_N_ 1
_Cj_ [(][x][∗][)][ ×][ N][C]j[2] [(][y][∗][)]


where we introduce additional “dummy” sets Cj[1] [=][ R][d][ or][ C]j[2] [=][ R][d][ when][ n][1][ ̸][=][ n][2][. The first term]
is linear and skew symmetric, and therefore can easily be shown to be Lipschitz continuous and
monotone. If all the constraint sets are closed and convex, then the rest of the terms are maximal
monotone, then the problem is of the form (1), meaning that projective splitting may be applied,
possibly using a stochastic oracle for the first term.

B ADDITIONAL RELATED WORK

The preprint by Bot et al. (2019) develops a stochastic version of Tseng’s method under the requirement that the noise variance converges to 0. In ML, this could be achieved with the use of perpetually
increasing batch sizes, a strategy that is impractical in many scenarios. The stochastic version of
FRB proposed by Van Dung & Vu (2021) has more practical noise requirements, but has stronger
assumptions on the problem which are rarely satisfied in ML applications: either uniform/strong
monotonicity or a bounded domain. The papers by Yurtsever et al. (2016) and Pedregosa et al.
(2019) consider stochastic variants of three-operator splitting, but require B in (1) to be cocoercive,
essentially restricting them to optimization problems.

There are several alternatives to the (stochastic) extragradient method that reduce the number of
gradient evaluations per iteration from two to one (Hsieh et al., 2019; Malitsky & Tam, 2020; Gidel
et al., 2019). However, these methods have more stringent stepsize limits, making it unclear a priori
whether they will outperform two-step methods.

DSEG is a stochastic version of EG (Hsieh et al., 2020). The primary innovation of DSEG is using
different stepsizes for the extrapolation and update steps, thereby resolving some of the convergence
issues affecting stochastic EG. As noted earlier, DSEG is the special case of our SPS method in which
_n = 0, that is, no regularizers/constraints are present in the underlying game. The analysis in (Hsieh_
et al., 2020) also did not consider the fixed stepsize choice given in Theorem 2.

In the context of GANs, several methods have been developed based on a variational inequality/monotone inclusion approach (Gidel et al., 2019; Daskalakis et al., 2018; Hsieh et al., 2019; 2020;
Böhm et al., 2020). Many of these papers point out that variational inequalities provide a principled
framework for studying the GAN training problem and correcting some of the flaws in the standard
method GDA.

C PROOF OF THEOREM 1

C.1 STOCHASTIC QUASI-FEJER MONOTONICITY

The key to the analysis is showing that the algorithm satisfies Stochastic Quasi-Fejer Monotonicity
(Combettes & Pesquet, 2015).
**Lemma 2 ((Combettes & Pesquet, 2015), Proposition 2.3). Suppose p[k]** _is a sequence of R[d]-valued_
_random variables defined on a probability space (Ω, F, P_ ). Let Fk = σ(p[1], . . ., p[k]). Let F be a
_nonempty, closed subset of R[d]. Suppose that, for every p ∈_ _F_ _, there exists χ[k](p) ≥_ 0, η[k](p) ≥
0, ν[k](p) ≥ 0 such that _k=1_ _[χ][k][(][p][)][ <][ ∞][,][ P]k[∞]=1_ _[η][k][(][p][)][ <][ ∞]_ _[and]_

(∀k ∈ N) [P]E[[∞]∥p[k][+1] _−_ _p∥[2]|Fk] ≤_ (1 + χ[k](p))∥p[k] _−_ _p∥[2]_ _−_ _ν[k](p) + η[k](p)._

_Then the following hold:_

_1. (∀p ∈_ _F_ ) : _∞k=1_ _[ν][k][(][p][)][ <][ ∞]_ _[a.s.]_

_2. p[k]_ _is bounded a.s.P_


_3. There exists_ Ω[˜] _such that P_ [Ω] = 1[˜] _and_ _∥p[k](ω) −_ _p∥_ _converges for every ω ∈_ Ω[˜] _and_
_p ∈_ _F_ _._ 


-----

C.2 IMPORTANT RECURSION FOR SPS

The following lemma summarizes the key recursion satisfied by Algorithm 1, to which we will apply
Lemma 2. Recall that L is the Lipschitz constant of B.
**Lemma 3. For Algorithm 1, suppose (9)–(11) hold and**


_ρk_ _ρ < 1/L._ (20)
_≤_

_n_

_i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ + 2(1][ −]_ _[ρL][)][∥][B][(][z][k][)][ −]_ _[w]n[k]+1[∥][2]_

X


_Let_


_Tk_ =[.] _[τ]_


_n_

_i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ + 1]ρτ_

X


_then for all p[∗]_ _∈S, with probability one_

E[∥p[k][+1] _−_ _p[∗]∥[2]|Fk] ≤_ (1 + C1αk[2] [+][ C][3][α][k][ρ]k[2][)][∥][p][k][ −] _[p][∗][∥][2][ −]_ _[α][k][ρ][k][T][k]_ [+][ C][2][α]k[2] [+][ C][4][α][k][ρ]k[2] (21)

_where C1, . . ., C4 are nonegative constants defined in (33), (34), (48), and (49) below, respectively._

Note that Tk is a scaled version of the approximation residual Gk defined in (14).

We proceed to first prove Lemma 3 and then exploit the implications of Lemma 2. Referring to (10)
and (11), let N = max[.] _j_ 1..4 Nj. To simplify the constants, we will use N in place of Nj for the
_∈_
noise variance bounds given in (10)-(11).

C.3 UPPER BOUNDING THE GRADIENT

Throughout the analysis, we fix some p[∗] = (z[∗], w1[∗] _[. . ., w]n[∗]+1[)][ ∈S][. All statements are with]_
probability one (almost surely), but for brevity we will omit this unless it needs to be emphasized.

In this section, we derive appropriate upper bounds for _ϕk_ to use in (13). We begin with _zϕk:_
_∥∇_ _∥[2]_ _∇_

_n+1_ _n_ _n_

2 2 2

_zϕk_ = _yi[k]_ 2 _yn[k]+1[∥][2][ + 2]_ _yi[k]_ = 2 _B(x[k]n+1[) +][ e][k]_ + 2 _yi[k]_
_∥∇_ _∥[2]_ _≤_ _∥_

_i=1_ _i=1_ _i=1_

X X _n_ X

[2] 2

4 _B(x[k]n+1[)][∥][2][ + 2]_ _yi[k]_ + 4 _e[k]_ _._
_≤_ _∥_ _∥_ _∥[2]_

_i=1_

X

Now next take expectations with respect to Fk and Ek, and use the bound on the variance of the noise
in (11), obtaining

_n_

2

E _zϕk_ _k,_ _k_ E 4 _B(x[k]n+1[)][∥][2][ + 2]_ _yi[k]_ + 4 _e[k]_ _k,_ _k_
_∥∇_ _∥[2]|F_ _E_ _≤_ " _∥_ _i=1_ _∥_ _∥[2]_ _F_ _E_ #
  X _n_

2

4(N + 1) _B(x[k]n+1[)][∥][2][ + 2]_ _yi[k]_ + 4N,
_≤_ _∥_

_i=1_

X


where we have used that yi[k] [is][ F][k][-measurable for][ i][ ∈] [1][..n][. Thus, taking expectations over][ E][k]
conditioned on Fk yields


E _∥∇zϕk∥[2]|Fk_ _≤_ 4(N + 1)E[∥B(x[k]n+1[)][∥][2][|F][k][] + 2]
 

We will now bound the two terms on the right side of (22).

C.3.1 FIRST TERM IN (22)

First, note that


_yi[k]_ + 4N. (22)
_i=1_

X


_∥B(z[k])∥[2]_ = ∥B(z[k]) − _B(z[∗]) + B(z[∗]))∥[2]_

_≤_ 2∥B(z[k]) − _B(z[∗])∥[2]_ + 2∥B(z[∗])∥[2]

_≤_ 2L[2]∥z[k] _−_ _z[∗]∥[2]_ + 2∥B(z[∗])∥[2]

_≤_ 2L[2]∥p[k] _−_ _p[∗]∥[2]_ + 2∥B(z[∗])∥[2]. (23)


-----

Now, returning to the first term on the right of (22), we have

_∥B(x[k]n+1[)][∥][2][ =][ ∥][B][(][z][k][) +][ B][(][x][k]n+1[)][ −]_ _[B][(][z][k][)][∥][2]_

_≤_ 2∥B(z[k])∥[2] + 2∥B(x[k]n+1[)][ −] _[B][(][z][k][)][∥][2]_

2 _B(z[k])_ + 2L[2] _x[k]n+1_
_≤_ _∥_ _∥[2]_ _∥_ _[−]_ _[z][k][∥][2]_

4L[2] _p[k]_ _p[∗]_ + 4 _B(z[∗])_ + 2L[2] _x[k]n+1_ (24)
_≤_ _∥_ _−_ _∥[2]_ _∥_ _∥[2]_ _∥_ _[−]_ _[z][k][∥][2]_

where we have used (23) to obtain (24).


For the third term in (24), we have from the calculation on line 7 of the algorithm that


_x[k]n+1_ _[−]_ _[z][k][ =][ −][ρ][k][(][r][k][ −]_ _[w]n[k]+1[) =][ −][ρ][k][(][B][(][z][k][) +][ ϵ][k][ −]_ _[w]n[k]+1[)][,]_


and therefore


_∥x[k]n+1_ _[−]_ _[z][k][∥][2][ =][ ρ]k[2][∥][B][(][z][k][) +][ ϵ][k][ −]_ _[w]n[k]+1[∥][2]_

_≤_ _ρ[2]∥B(z[k]) + ϵ[k]_ _−_ _wn[k]+1[∥][2]_

_≤_ 3ρ[2](∥B(z[k])∥[2] + ∥ϵ[k]∥[2] + ∥wn[k]+1[∥][2][)][.]

We next take expectations conditioned on Fk and use the noise variance bound (10) to obtain

E _x[k]n+1_ E 3ρ[2][ ] _B(z[k])_ + _ϵ[k]_ + _wn[k]+1[∥][2][]_ _k_
_∥_ _[−]_ _[z][k][∥][2][ | F][k]_ _≤_ _∥_ _∥[2]_ _∥_ _∥[2]_ _∥_ _| F_
  3ρ[2][ ](N + 1) _B(z[k])_ + _wn[k]+1[∥][2][ +][ N]_ _._ 

_≤_ _∥_ _∥[2]_ _∥_

Therefore 

E _x[k]n+1_ 6ρ[2][ ](N + 1) _B(z[k])_ + _wn[k]+1_ _n+1[∥][2][ +][ ∥][w]n[∗]+1[∥][2][]_ + 3ρ[2]N
_∥_ _[−]_ _[z][k][∥][2][ | F][k]_ _≤_ _∥_ _∥[2]_ _∥_ _[−]_ _[w][∗]_
  = 6ρ[2][]2(N + 1)L[2]∥p[k] _−_ _p[∗]∥[2]_ + 2(N + 1)∥B(z[∗])∥[2]

+ _wn[k]+1_ _n+1[∥][2][ +][ ∥][B][(][z][∗][)][∥][2][]_ + 3ρ[2]N
_∥_ _[−]_ _[w][∗]_

6ρ[2][ ]2(N + 1)L[2] _p[k]_ _p[∗]_ + _wn[k]+1_ _n+1[∥][2][]_
_≤_ _∥_ _−_ _∥[2]_ _∥_ _[−]_ _[w][∗]_

+ 18ρ[2](N + 1)∥B(z[∗])∥[2] + 3ρ[2]N

_≤_ 18ρ[2](N + 1) (L[2] + 1)∥p[k] _−_ _p[∗]∥[2]_ + ∥B(z[∗])∥[2][] + 3ρ[2]N (25)

where in the equality uses (23) and wn[∗]+1 [=] [ B][(][z][∗][)][. Combining (24) and (25), we arrive at]

E _B(x[k]n+1[)]_ _Fk_ _≤_ 4L[2][]1 + 9ρ[2](L[2] + 1)(N + 1) _∥p[k]_ _−_ _p[∗]∥[2]_
h i + 4 1 + 9ρ[2]L[2](N + 1) _B(z[∗])_ + 6ρ[2]L[2]N. (26)

[2] _∥_ _∥[2]_

  


C.3.2 SECOND TERM IN (22)

For i ∈ 1..n, line 5 of the algorithm may be rearranged into yi[k] [=][ τ][ −][1][(][z][k][ −] _[x]i[k][) +][ w]i[k][,][ so]_


(τ _[−][1](z[k]_ _−_ _x[k]i_ [) +][ w]i[k][)]
_i=1_

X


_yi[k]_
_i=1_

X


2
(z[k] _−_ _x[k]i_ [)] + 2
_i=1_

Xn

_z[k]_ _x[k]i_
_i=1_ _∥_ _−_ _[∥][2][ + 2]_

X


_≤_ 2 _τ_ _[−][1]_

_≤_ 2nτ _[−][2]_


_≤_ 2 _τ_ _[−][1]_ (z[k] _−_ _x[k]i_ [)] + 2 _wi[k]_

_i=1_ _i=1_

Xn Xn

2

_≤_ 2nτ _[−][2]_ _i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ + 2]_ _i=1_ _wi[k]_
X Xn

_≤_ 4n[2]τ _[−][2]∥z[k]_ _−_ _z[∗]∥[2]_ + 4nτ _[−][2]_ _i=1_ _∥z[∗]_ _−_ _x[k]i_ _[∥][2][ + 4][n]_
X


_wi[k]_ _i_
_i=1_ _∥_ _[−]_ _[w][∗][∥][2][ + 4]_

X


_wi[∗]_
_i=1_

X


_≤_ 4n[2](τ _[−][2]_ + 1)∥p[k] _−_ _p[∗]∥[2]_ + 4nτ _[−][2]_


_z[∗]_ _x[k]i_
_i=1_ _∥_ _−_ _[∥][2][ + 4]_

X


_wi[∗]_ _._ (27)
_i=1_

X


-----

By the definition of the solution set in (5), wi[∗] _i_
the resolvent is single-valued (Bauschke & Combettes, 2017, Cor. 23.9) we therefore obtain S _[∈]_ _[A][i][(][z][∗][)][, so][ z][∗]_ [+][ τw][∗] _[∈]_ [(][I][ +][ τA][i][)(][z][∗][)][,][ and since]

_z[∗]_ = (I + τAi)[−][1](I + τAi)(z[∗]) = JτAi (z[∗] + τwi[∗][)][.]

From lines 3 and 4 of the algorithm, we also have x[k]i [=][ J][τA]i [(][z][k][ +][ τw]i[k][)][ for][ i][ ∈] [1][..n][. Thus, using]
the nonexpansiveness of the resolvent (Bauschke & Combettes, 2017, Def. 4.1 and Cor. 23.9), we
have


_z[∗]_ _x[k]i_
_i=1_ _∥_ _−_ _[∥][2][ =]_

X


_JτAi_ (z[k] + τwi[k][)][ −] _[J][τA]i_ [(][z][∗] [+][ τw]i[∗][)]

_i=1_

Xn

_z[k]_ + τwi[k] _i_
_i=1_ _∥_ _[−]_ _[z][∗]_ _[−]_ _[τw][∗][∥][2]_

Xn

_i=1_ _∥z[k]_ _−_ _z[∗]_ + τ (wi[k] _[−]_ _[w]i[∗][)][∥][2]_

X


2n _z[k]_ _z[∗]_ + 2τ [2] _wi[k]_ _i_
_≤_ _∥_ _−_ _∥[2]_ _i=1_ _∥_ _[−]_ _[w][∗][∥][2]_
X

_≤_ 2(n + τ [2])∥p[k] _−_ _p[∗]∥[2]._ (28)


Combining (27) and (28) yields

_n_

2
_yi[k]_ _≤_ 12n[2]τ _[−][2](n + τ_ [2])∥p[k] _−_ _p[∗]∥[2]_ + 4
_i=1_

X

Combining (26) and (29) with (22) yields


_wi[∗]_ _._ (29)
_i=1_

X


_zϕk_ _k_ 24 (1 + 9ρ[2])(L[2] + 1)[2](N + 1)[2] + n[2]τ (n + τ [2]) _p[k]_ _p[∗]_
_∥∇_ _∥[2]_ _| F_ _≤_ _[−][2]_ _∥_ _−_ _∥[2]_
  


+ 16(N + 1) 1 + 9ρ[2]L[2](N + 1) _∥B(z[∗])∥[2]_ + 8
  


_wi[∗]_
_i=1_

X


+ 24ρ[2]L[2](N + 1)N + 4N. (30)

C.3.3 DUAL GRADIENT NORM

Considering that ∇ϕk is taken with respect to the subspace P, the gradients with respect to the dual
variables are — see for example Eckstein & Svaiter (2009) — for each i ∈ 1..(n + 1),


_n+1_

_x[k]j_
_j=1_

X


_n+1_

_j=1(x[k]i_ _[−]_ _[x]j[k][)]_

X


_wi_ _ϕk_ = _x[k]i_
_∥∇_ _∥[2]_ _[−]_


_n + 1_


_n + 1_

_n+1_


_x[k]i_ _j_
_j=1_ _∥_ _[−]_ _[x][k][∥][2]_

X


_n+1_

_j=1_

X


_x[k]i_ _j_
_∥_ _[−]_ _[z][k][∥][2][ +][ ∥][z][k][ −]_ _[x][k][∥][2][]_


_≤_ 2


Summing this inequality for i ∈ 1..(n + 1) and collecting terms yields


_n+1_

_wi_ _ϕk_ 4(n + 1)
_∥∇_ _∥[2]_ _≤_
_i=1_

X


_n+1_

_x[k]i_
_i=1_ _∥_ _[−]_ _[z][k][∥][2][,]_

X


-----

so taking expectations conditioned on Fk produces


_n+1_

E[∥∇wi _ϕk∥[2]_ _| Fk] ≤_ 4(n + 1)
_i=1_

X


_n+1_

E[ _x[k]i_
_i=1_ _∥_ _[−]_ _[z][k][∥][2][ | F][k][]]_

X


4(n + 1)E[ _x[k]n+1_ E[ _x[k]i_
_≤_ _∥_ _[−]_ _[z][k][∥][2][ | F][k][] + 4(][n][ + 1)]_ _i=1_ _∥_ _[−]_ _[z][k][∥][2][ | F][k][]]_

X

4(n + 1)E[ _x[k]n+1_
_≤_ _∥_ _n_ _[−]_ _[z][k][∥][2][ | F][k][]]_

+ 8(n + 1) E[ _x[k]i_

_i=1_ _∥_ _[−]_ _[z][∗][∥][2][ | F][k][] + 8(][n][ + 1)][2][∥][z][k][ −]_ _[z][∗][∥][2]_

X


4(n + 1)E[ _x[k]n+1_
_≤_ _∥_ _n_ _[−]_ _[z][k][∥][2][|F][k][]]_

+ 8(n + 1) E[ _x[k]i_

_i=1_ _∥_ _[−]_ _[z][∗][∥][2][|F][k][] + 8(][n][ + 1)][2][∥][p][k][ −]_ _[p][∗][∥][2]_

X

_≤_ 8(n + 1) 3n + 2τ [2] + 1 + 9ρ[2](L[2] + 1)(N + 1) _∥p[k]_ _−_ _p[∗]∥[2]_

+ 72ρ[2](n + 1)(N + 1) _B(z[∗])_ + 12ρ[2](n + 1) _N,_ (31)
_∥_ _∥[2]_

where the final inequality employs (25) and (28).

All told, using (30) and (31) and simplifying the constants, one obtains


_n+1_

E[∥∇ϕk∥[2] _| Fk] = E[∥∇zϕk∥[2]_ _| Fk] +_ E[∥∇wi _ϕk∥[2]|Fk]_

_i=1_

X

_C1_ _p[k]_ _p[∗]_ + C2, (32)
_≤_ _∥_ _−_ _∥[2]_


where

and


_C1 = 24(1 + 10ρ[2])(n + 1)(L[2]_ + 1)[2](N + 1)[2]

+ 8(n + 1)  2τ [2] + 6(n + 1) + 1 + 3(n + 1)[2]τ _[−][2][]_ (33)


_C2 = 16(N + 1)_ 1 + 4ρ[2](n + 1) + 9ρ[2]L[2](N + 1) _∥B(z[∗])∥[2]_ + 8∥
 


_wi[∗]_
_i=1_ _[∥][2]_

X


+ 12ρ[2]N (2L[2](N + 1) + n + 1) + 4N. (34)

C.4 LOWER BOUND FOR ϕk-GAP

Recalling (13), that is,

_∥p[k][+1]_ _−_ _p[∗]∥[2]_ = ∥p[k] _−_ _p[∗]∥[2]_ _−_ 2αk(ϕk(p[k]) − _ϕk(p[∗])) + αk[2][∥∇][ϕ][k][∥][2][.]_

We may use the gradient bound from (32) to obtain

E[∥p[k][+1] _−_ _p[∗]∥[2]_ _| Fk] ≤_ (1 + C1αk[2][)][∥][p][k][ −] _[p][∗][∥][2][ −]_ [2][α][k][E][[][ϕ][k][(][p][k][)][ −] _[ϕ][k][(][p][∗][)][ | F][k][] +][ C][2][α]k[2][.]_ (35)

We now focus on finding a lower bound for the term E[ϕk(p[k]) − _ϕk(p[∗]) | Fk], which we call the_
“ϕk-gap”. Recall that for p = (z, w1, . . ., wn+1),

_n+1_


_i=1_ _⟨z −_ _x[k]i_ _[, y]i[k]_ _[−]_ _[w][i][⟩][.]_

X


_ϕk(p) =_


For each i ∈ 1..(n +1), define ϕi,k(p) =[.] _⟨z −_ _x[k]i_ _[, y]i[k]_ _[−]_ _[w][i][⟩][.][ We will call][ E][[][ϕ][i,k][(][p][k][)]_ _[−]_ _[ϕ][i,k][(][p][∗][)][ | F][k][]]_
the “ϕi,k-gap”. Note that ϕk(p) = _i=1_ _[ϕ][i,k][(][p][)][.]_

[P][n][+1]


-----

C.5 LOWER BOUND FOR ϕi,k-GAP OVER i 1..n
_∈_

For i ∈ 1..n, we have from line 5 of the algorithm that

_z[k]_ _−_ _x[k]i_ [=][ τ] [(][y]i[k] _[−]_ _[w]i[k][)][.]_

Since ϕi,k(p[k]) = ⟨z[k] _−_ _x[k]i_ _[, y]i[k]_ _[−]_ _[w]i[k][⟩][,][ one may conclude that for][ i][ ∈]_ [1][..n][,]

_ϕi,k(p[k]) =_ _[τ]2_ _[∥][y]i[k]_ _[−]_ _[w]i[k][∥][2][ + 1]2τ_ _[∥][z][k][ −]_ _[x]i[k][∥][2][.]_


On the other hand, for p[∗] _∈S and i ∈_ 1..n, one also has

_−ϕi,k(p[∗]) = ⟨z[∗]_ _−_ _x[k]i_ _[, w]i[∗]_ _[−]_ _[y]i[k][⟩≥]_ [0] (36)

by the monotonicity of Ai. Therefore, for i 1..n, it holds that
_∈_

_ϕi,k(p[k]) −_ _ϕi,k(p[∗]) ≥_ _[τ]2_ _[∥][y]i[k]_ _[−]_ _[w]i[k][∥][2][ + 1]2τ_ _[∥][z][k][ −]_ _[x]i[k][∥][2][,]_

and taking expectations conditioned on Fk leads to

E[ϕi,k(p[k]) − _ϕi,k(p[∗]) | Fk] ≥_ _[τ]2_ _[∥][y]i[k]_ _[−]_ _[w]i[k][∥][2][ + 1]2τ_ _[∥][z][k][ −]_ _[x]i[k][∥][2]_ (37)

where we have used that x[k]i [and][ y]i[k] [are both][ F][k][-measurable for][ i][ ∈] [1][..n][.]

C.6 LOWER BOUND FOR ϕn+1,k-GAP

From lines 6-7 of the algorithm, we have


_z[k]_ _−_ _x[k]n+1_ [=][ ρ][k][(][B][(][z][k][)][ −] _[w]n[k]+1_ [+][ ϵ][k][)][.]


Therefore,


_ϕn+1,k(p[k]) = ⟨z[k]_ _−_ _x[k]n+1[, y]n[k]+1_ _[−]_ _[w]n[k]+1[⟩]_ (38)

= ⟨z[k] _−_ _x[k]n+1[, B][(][z][k][)][ −]_ _[w]n[k]+1[⟩]_ [+][ ⟨][z][k][ −] _[x]n[k]+1[, y]n[k]+1_ _[−]_ _[B][(][z][k][)][⟩]_

= ρk⟨B(z[k]) − _wn[k]+1_ [+][ ϵ][k][, B][(][z][k][)][ −] _[w]n[k]+1[⟩]_ [+][ ⟨][z][k][ −] _[x]n[k]+1[, y]n[k]+1_ _[−]_ _[B][(][z][k][)][⟩]_

=(a) ρk∥B(z[k]) − _wn[k]+1[∥][2][ +][ ⟨][z][k][ −]_ _[x]n[k]+1[, y]n[k]+1_ _[−]_ _[B][(][z][k][)][⟩]_ [+][ ρ][k][⟨][ϵ][k][, B][(][z][k][)][ −] _[w]n[k]+1[⟩]_

= ρk∥B(z[k]) − _wn[k]+1[∥][2][ +][ ⟨][z][k][ −]_ _[x]n[k]+1[, B][(][x]n[k]+1[)][ −]_ _[B][(][z][k][)][⟩]_ [+][ ⟨][z][k][ −] _[x]n[k]+1[, e][k][⟩]_

+ ρk⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩]_

_≥_ _ρk∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ _[L][∥][z][k][ −]_ _[x][k]n+1[∥][2][ +][ ⟨][z][k][ −]_ _[x]n[k]+1[, e][k][⟩]_

+ ρk⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩]_

= ρk∥B(z[k]) − _wn[k]+1[∥][2][ −]_ _[L][∥][ρ][k][(][B][(][z][k][)][ −]_ _[w]n[k]+1_ [+][ ϵ][k][)][∥][2][ +][ ⟨][z][k][ −] _[x]n[k]+1[, e][k][⟩]_

+ ρk⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩]_

= ρk∥B(z[k]) − _wn[k]+1[∥][2][ −]_ _[ρ][2]k[L][∥][B][(][z][k][)][ −]_ _[w]n[k]+1_ [+][ ϵ][k][∥][2][ +][ ⟨][z][k][ −] _[x]n[k]+1[, e][k][⟩]_

+ ρk⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩]_

= ρk(1 − _ρkL)∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ _[ρ][2]k[L][∥][ϵ][k][∥][2][ +][ ⟨][z][k][ −]_ _[x][k]n+1[, e][k][⟩]_

+ ρk(1 − 2ρkL)⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩][,]_ (39)

where equality (a) uses line 8 of the algorithm and the inequality employs the Cauchy-Schwartz
inequality followed by Lipschitz continuity of B.

On the other hand,


_−ϕn+1,k(p[∗]) = ⟨z[∗]_ _−_ _x[k]n+1[, w]n[∗]+1_ _[−]_ _[y]n[k]+1[⟩]_

= ⟨z[∗] _−_ _x[k]n+1[, B][(][z][∗][)][ −]_ _[B][(][x][k]i_ [)][⟩] [+][ ⟨][x]n[k]+1 _[−]_ _[z][∗][, e][k][⟩]_

_x[k]n+1_ (40)
_≥⟨_ _[−]_ _[z][∗][, e][k][⟩][,]_


-----

where the second equality uses line 8 of the algorithm and the inequality follows from the monotonicity
of B.

Combining (39) and (40) yields
_ϕn+1,k(p[k]) −_ _ϕn+1,k(p[∗]) ≥_ _ρk(1 −_ _ρkL)∥B(z[k]) −_ _wn[k]+1[∥][2][ +][ ρ][k][(1][ −]_ [2][ρ][k][L][)][⟨][ϵ][k][, B][(][z][k][)][ −] _[w]n[k]+1[⟩]_

+ ⟨z[k] _−_ _x[k]n+1[, e][k][⟩]_ [+][ ⟨][x][k]n+1 _[−]_ _[z][∗][, e][k][⟩−]_ _[ρ]k[2][L][∥][ϵ][k][∥][2]_

= ρk(1 − _ρkL)∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ _[ρ][2]k[L][∥][ϵ][k][∥][2]_

+ ρk(1 − 2ρkL)⟨ϵ[k], B(z[k]) − _wn[k]+1[⟩]_ [+][ ⟨][z][k][ −] _[z][∗][, e][k][⟩][.]_ (41)

Now, if we take expectations conditioned on Fk and use (9), we obtain
E _⟨z[k]_ _−_ _z[∗], e[k]⟩_ _Fk_ = ⟨z[k] _−_ _z[∗], E[e[k]_ _| Fk]⟩_ = 0. (42)
Similarly, (9) also yields
 
E _ϵ[k], B(z[k])_ _wn[k]+1[⟩]_ _k_ = E[ϵ[k] _k], B(z[k])_ _wn[k]+1_ = 0. (43)
_⟨_ _−_ _F_ _|F_ _−_
Thus, using (42) and (43) and taking expectations of (41) yields
 
E[ϕn+1,k(p[k]) − _ϕn+1,k(p[∗]) | Fk] ≥_ _ρk(1 −_ _ρkL)∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ _[ρ][2]k[L][E][[][∥][ϵ][k][∥][2][|F][k][]]_

_≥_ _ρk(1 −_ _ρL)∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ _[ρ]k[2][NL][(1 +][ ∥][B][(][z][k][)][∥][2][)][,]_
(44)
where in the second inequality we used (12) and the noise variance bound (10). Recall from (12) that
1 − _ρL > 0._

Next, we remark that
_∥B(z[k])∥[2]_ = ∥B(z[k]) − _B(z[∗]) + B(z[∗])∥[2]_

_≤_ 2L[2]∥z[k] _−_ _z[∗]∥[2]_ + 2∥B(z[∗])∥[2] _≤_ 2L[2]∥p[k] _−_ _p[∗]∥[2]_ + 2∥B(z[∗])∥[2].
Substituting this inequality into (44) yields
E[ϕn+1,k(p[k]) − _ϕn+1,k(p[∗])|Fk] ≥_ _ρk(1 −_ _ρL)∥B(z[k]) −_ _wn[k]+1[∥][2]_

_−_ 2ρ[2]k[NL][3][∥][p][k][ −] _[p][∗][∥][2][ −]_ _[ρ]k[2][NL][(1 + 2][∥][B][(][z][∗][)][∥][2][)][.]_ (45)

**Finalizing the lower bound on the ϕk-gap** Summing (37) over i ∈ 1..n and using (45) yields

_n+1_


E[ϕk(p[k]) − _ϕk(p[∗])|Fk] =_


E[ϕi,k(p[k]) − _ϕi,k(p[∗])|Fk]_
_i=1_

X


_≥_ _[τ]2_


_n_ _n_

_i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ + 1]2τ_ _i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2]_

X X

+ ρk(1 − _ρL)∥B(z[k]) −_ _wn[k]+1[∥][2][ −]_ [2][ρ][2]k[NL][3][∥][p][k][ −] _[p][∗][∥][2]_

_−_ _ρ[2]k[NL][(1 + 2][∥][B][(][z][∗][)][∥][2][)][.]_ (46)


C.7 ESTABLISHING STOCHASTIC QUASI-FEJER MONOTONICITY

Returning to (35),
E[∥p[k][+1] _−_ _p[∗]∥[2]_ _| Fk] ≤_ (1 + C1αk[2][)][∥][p][k][ −] _[p][∗][∥][2][ −]_ [2][α][k][E][[][ϕ][k][(][p][k][)][ −] _[ϕ][k][(][p][∗][)][ | F][k][] +][ C][2][α]k[2][,]_
we may now substitute (46) for the expectation on the right-hand side. First, define


_Tk_ =[.] _[τ]_


_n_

_i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ + 1]ρτ_

X


_i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ + 2(1][ −]_ _[ρL][)][∥][B][(][z][k][)][ −]_ _[w]n[k]+1[∥][2][,]_

X


after which we may use (46) in (35) to yield
E[∥p[k][+1] _−_ _p[∗]∥[2]_ _| Fk] ≤_ (1 + C1αk[2] [+][ C][3][α][k][ρ]k[2][)][∥][p][k][ −] _[p][∗][∥][2][ −]_ _[α][k][ρ][k][T][k]_ [+][ C][2][α]k[2] [+][ C][4][α][k][ρ]k[2] (47)
where C1 and C2 are defined as before in (33) and (34) and
_C3 = 4NL[3]_ (48)

_C4 = 2NL(1 + 2∥B(z[∗])∥[2])._ (49)
This completes the proof of Lemma 3.


-----

C.8 A CONVERGENCE LEMMA

Before establishing almost-sure convergence, we need the following lemma to derive convergence
of the iterates from convergence of Tk defined above. Note that a more elaborate result would be
needed in an infinite-dimensional setting.

**Lemma 4. For deterministic sequences z[k]** _∈_ R[(][n][+1)][d], {(wi[k][)]i[n]=1[+1][} ∈P][, and][ {][(][x]i[k][, y]i[k][)]i[n]=1[+1][} ∈]
R[2(][n][+1)][d], suppose that yi[k] _[∈]_ _[A][i][(][x]i[k][)][ for][ i][ ∈]_ [1][..n][,][ P]i[n]=1[+1] _[w]i[k]_ [= 0][,]

_n_ _n_

_ξ1_ _i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ +][ ξ][2]_ _i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ +][ ξ][3][∥][B][(][z][k][)][ −]_ _[w]n[k]+1[∥][2][ →]_ [0] (50)

X X

_for scalars ξ1, ξ2, ξ3 > 0, and p[k][ .]= (z[k], w1[k][, . . ., w]n[k]+1[)][ →]_ _p [ˆ]_ = (ˆ[.] _z, ˆw1, . . ., ˆwn+1). Then ˆp ∈S._


_Proof. Fix any i_ 1, . . ., n . Since _yi[k]_ _i_ _i_ _wi, we also have_
_yi[k]_ _wi. Similarly, ∈{ (50) also implies that}_ _∥_ _z[−][k]_ _[w]x[k][∥→][k]i_ [0][ by][ (50)][ and][ w][k]z we also have[→] [ˆ] _x[k]i_ _z._
Sincewˆi _[→] yA[ˆ]ii[k](ˆz[∈]). Since[A][i][(][x]i[k] i[)][ and] was arbitrary, the preceding conclusions hold for[ (][x]i[k][, y]i[k][)][ →]_ [(ˆ]z, ˆwi ∥), (Bauschke & Combettes, 2017, Prop. 20.37) implies− _[∥→]_ [0][, so from][ z] i[k][ →]1..n[ˆ] . _[→]_ [ˆ]
_∈_ _∈_

Now, (50) also implies that _B(z[k])_ _wn[k]+1[∥→]_ [0][. Therefore, since][ w]n[k]+1 _wn+1, we also have_
_∥_ _−_ _[→]_ [ˆ]
_B(z[k])_ _wˆn+1. Much as before, since (z[k], B(z[k]))_ (ˆz, ˆwn+1), we may apply (Bauschke &
_→_ _→_
Combettes, 2017, Prop. 20.37) to conclude that that ˆwn+1 = B(ˆz).

Since the linear subspace defined in (6) must be closed, the limit (ˆz, ˆw1, . . ., ˆwn+1) of
_P_
_{(z[k], w1[k][, . . ., w]n[k]+1[)][} ⊂P][ must be in][ P][, hence][ P][n]i=1[+1]_ _w[ˆ]i = 0._

Thus, the pointn+1 ˆp = (ˆz, ˆw1, . . ., ˆwn+1) satisfies ˆwi ∈ _Ai(ˆz) for i ∈_ 1..n, ˆwn+1 = B(ˆz), and
_i=1_ _w[ˆ]i = 0. These are the three conditions defining membership in S from (5), so ˆp ∈S._
P

C.9 FINISHING THE PROOF OF THEOREM 1

Given _k_ _[α]k[2]_ _[<][ ∞][, and][ P][ α][k][ρ]k[2]_ _[<][ ∞][,][ (47)][ satisfies the conditions of][ Stochastic Quasi-Fejer]_

_Monotonicity as given in Lemma 2. By applying Lemma 2, we conclude that there exist Ω1, Ω2, Ω3_
such that P [Ωi] = 1 for i = 1, 2, 3 and

[P]

1. for all v Ω1
_∈_

_∞_

_αkρkTk(v) <_ _,_ (51)
_∞_
_k=1_

X


2. for all v Ω2, and p[∗], _p[k](v)_ _p[∗]_ converges to a finite nonnegative random-variable,
_∈_ _∈S_ _∥_ _−_ _∥_

3. for all v Ω3, p[k](v) remains bounded.
_∈_

Since _k=1_ _[α][k][ρ][k][ =][ ∞][, (51) implies that for all][ v][ ∈]_ [Ω][1][ there exists a subsequence][ q][k][(][v][)][ such that]

_Tqk(v)_ 0. (52)

[P][∞] _→_

Let Ω[′] = Ω1 ∩ Ω2 ∩ Ω3 and note that P [Ω[′]] = 1. Choose v ∈ Ω[′]. Since p[k](v) remains bounded, so
does p[q][k][(][v][)](v) for qk(v) defined above in (52). Thus there exists a subsequence rk(v) _qk(v) and_
_⊆_
_pthat is,ˆ(v) ∈_ R[(][n][+2)][d] such that p[r][k][(][v][)](v) → _pˆ(v). But since Tqk(v) →_ 0, it also follows that Trk(v) → 0,


_n_ _n_

_τ_
_ρ_ _∥yi[r][k][(][v][)](v) −_ _wi[r][k][(][v][)](v)∥[2]_ + ρτ[1] _∥z[r][k][(][v][)](v) −_ _x[r]i_ _[k][(][v][)](v)∥[2]_

_i=1_ _i=1_

X X

+ 2(1 − _ρL)∥B(z[r][k][(][v][)](v)) −_ _wn[r][k]+1[(][v][)][(][v][)][∥][2][ →]_ [0][.]

We then have from Lemma 4 that ˆp(v) ∈S.


-----

Since p[r][k][(][v][)](v) → _pˆ(v), it follows that ∥p[r][k][(][v][)](v)_ _−_ _pˆ(v)∥→_ 0. But since ˆp(v) ∈S, ∥p[k](v) _−_ _pˆ(v)∥_
converges by point 2 above. Thus

lim _p(v)_ = lim _p(v)_ = 0.
_k_ _∥_ _k_ _∥_
_→∞_ _[∥][p][k][(][v][)][ −]_ [ˆ] _→∞_ _[∥][p][r][k][(][v][)][(][v][)][ −]_ [ˆ]

Therefore p[k](v) → _pˆ(v) ∈S. Thus there exists ˆp ∈S such that p[k]_ _→_ _pˆ a.s., which completes the_
proof of Theorem 1.

C.10 TWO ADDITIONAL RESULTS

In this section, we prove two additional useful results about SPS. First, that x[k]i _z (a.s.) for_
_i = 1, . . ., n. Second, that Gk_ 0 (a.s.). _[→]_ [ˆ]
_→_

Note that
_x[k]i_ [=][ J][τA]i [(][z][k][ +][ τw]i[k][)]

and since z[k] and wi[k] [convergence a.s., so does][ x]i[k][. Consider the subsequence][ q][k][(][v][)][ such that][ (52)]
holds. Then
_z[q][k][(][v][)]_ _x[q]i_ _[k][(][v][)]_ 0
_−_ _→_

thus
_x[q]i_ _[k][(][v][)]_ _z.ˆ_
_→_

Since x[k]i [converges to some limit (a.s.), that limit must be][ ˆ]z.

Recall that


_Gk_ =[.] _i=1_ _i_ _i_ _i=1_ _i_ _n+1[∥][2][.]_

_[∥][y][k]_ _[−]_ _[w][k][∥][2][ +][ P][n]_ _[∥][z][k][ −]_ _[x][k][∥][2][ +][ ∥][B][(][z][k][)][ −]_ _[w][k]_

We have shown that z[k] and x[k]i [share the same limit for][ i][ = 1][, . . ., n][ (a.s.). Therefore][ z][k][ −] _[x]i[k]_

[P][n]

(a.s.). Since _[→]_ [0]
_yi[k]_ _[−]_ _[w]i[k]_ [=][ τ][ −][1][(][z][k][ −] _[x]i[k][)][,]_

it follows that yi[k] _i_

_[−]_ _[w][k]_ _[→]_ [0][ (a.s.) for][ i][ = 1][, . . ., n][. Therefore]

_Gk_ _B(ˆz)_ _wˆn+1_ _._
_→∥_ _−_ _∥[2]_

But since (z, ˆw1, . . ., ˆwn+1) ∈S, ˆwn+1 = B(ˆz) implying that Gk → 0 (a.s.).

D PROOF OF LEMMA 1

If Gk = 0, then

_∀i = 1, . . ., n :_ _yi[k]_ [=][ w]i[k] [and][ z][k][ =][ x]i[k][.] (53)

Since yi[k] _[∈]_ _[A][i][(][x]i[k][)][ for][ i][ = 1][, . . ., n][, (53) implies that that]_

_i_ 1..n : _wi[k]_ (54)
_∀_ _∈_ _[∈]_ _[A][i][(][z][k][)][.]_

Furthermore Gk = 0 also implies that wn[k]+1 [=][ B][(][z][k][)][. Finally, since][ P]i[n]=1[+1] _[w]i[k]_ [= 0][, we have that]

(z[k], w1[k][, . . ., w]n[k]+1[)][ ∈S][.]

Conversely, suppose (z[k], w1[k][, . . ., w]n[k]+1[)][ ∈S][. The definition of][ S][ implies that][ B][(][z][k][) =][ w]n[k]+1 [and]
furthermore that wi[k]
we may writeresolvent JτAi t = ([k]i [=]I[ z] +[∈][k] τA[ +][A][ τw][i]i[(])[z][−][k]i[k][1][)][ for]is single-valued (Bauschke & Combettes, 2017, Prop. 23.8), we must[∈] [(][ i][I][ +][ ∈][ τA][1][..n][i][)(][. For any][z][k][)][, implying][ i][ ∈] [1][ z][..n][k][, considering line 3 of Algorithm 1,][ ∈] [(][I][ +][ τA][i][)][−][1][(][t]i[k][)][. But since the]
have z[k] = (I + τAi)[−][1](t[k]i [)][. Thus, by line 4, we have][ x]i[k] [=][ z][k][. We may also derive from line 5 that]

_yi[k]_ [=][ τ][ −][1][(][t]i[k] _[−]_ _[x]i[k][) =][ τ][ −][1][(][z][k][ +][ τw]i[k]_ _[−]_ _[z][k][) =][ w]i[k][.]_

Thus, since x[k]i [=][ z][k][ and][ y]i[k] [=][ w]i[k] [for][ i][ = 1][, . . ., n][ and][ w]n[k]+1 [=][ B][(][z][k][)][, we have that][ G][k] [= 0][.]


-----

E PROOF OF THEOREM 2

In addition to the proof, we provide a more detailed statement of the theorem:
**Theorem 3. Fix the total iterations K ≥** 1 of Algorithm 1 and set

_k = 1, . . ., K :_ _ρk = ρ = min[.]_ _K_ _[−][1][/][4],_ [1] (55)
_∀_ 2L
 

_∀k = 1, . . ., K :_ _αk = α =[.]_ _Cf_ _ρ[2]_ (56)

_for some Cf > 0. Suppose (9)-(11) hold. Then for any p[∗]_ _∈S,_


_K_

E[Gj]
_j=1_ _≤_ [8][L]C[3][ exp (]f min[C]{[f]τ, τ[(][C][−][1][ +][1]}[ C]K[3][))]

X

_K_

E[Gj]
_j=1_ _≤_ _C[exp (]f min[C]{[f]τ, τ[(][C][1][−][ +][1]}[ C]K[3][1][))][/][4]_ 

X


_p[1]_ _p[∗]_ + _[C][f]_ _[C][2][ +][ C][4]_
_∥_ _−_ _∥[2]_ _Cf_ _C1 + C3_


_p[1]_ _p[∗]_ + _[C][f]_ _[C][2][ +][ C][4]_
_∥_ _−_ _∥[2]_ _Cf_ _C1 + C3_




_for K < (2L)[4]_ (57)

_for K ≥_ (2L)[4]. (58)


_where Gk is the approximation residual defined in (14), and C1, C2, C3, C4 are the nonegative_
_constants defined in (33), (34), (48), and (49), respectively. Therefore,_

_K_

1

E[Gj] = (K _[−][1][/][4])._

_K_ _O_

_j=1_

X

_Proof. Fix αk = α and ρk = ρ, where α and ρ are the respective right-hand sides of (55)-(56)._
Lemma 3 implies that (21) so long as (9)-(11) hold and the stepsize ρ satisfies ρ < L[−][1]. Since


_ρ = min_ _K_ _[−][1][/][4],_ [1]

2L



we conclude that (21) applies.

Rewriting (21) with αk = α and ρk = ρ, we have


_≤_ 2[1]L _[,]_


E[∥p[k][+1] _−_ _p[∗]∥[2]_ _| Fk] ≤_ (1 + C1α[2] + C3αρ[2])∥p[k] _−_ _p[∗]∥[2]_ _−_ _αρTk + C2α[2]_ + C4αρ[2].

Therefore, taking expectations over _k, we have_
_F_

E∥p[k][+1] _−_ _p[∗]∥[2]_ _≤_ (1 + C1α[2] + C3αρ[2])E∥p[k] _−_ _p[∗]∥[2]_ _−_ _αρETk + C2α[2]_ + C4αρ[2]. (59)

Recall that


_Tk_ =[.] _[τ]_


_n_

_i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ + 1]ρτ_

X


_z[k]_ _x[k]i_ _n+1[∥][2][,]_
_i=1_ _∥_ _−_ _[∥][2][ + 2(1][ −]_ _[ρL][)][∥][B][(][z][k][)][ −]_ _[w][k]_

X


where for the first two terms we have simply set ρ = ρ because the stepsize is constant. However,
for the final term, we will still use an upper bound, ρ, on ρ. In the current setting, we know that
_ρ ≤_ (1/2)L[−][1] and therefore we may set ρ = (1/2)L[−][1]. Thus 1 − _ρL = 1/2, leading to_


_i=1_ E∥z[k] _−_ _x[k]i_ _[∥][2][ +][ ρ][E][∥][B][(][z][k][)][ −]_ _[w]n[k]+1[∥][2][.]_

X


E _yi[k]_ _i_
_i=1_ _∥_ _[−]_ _[w][k][∥][2][ +][ τ][ −][1]_

X


_ρETk = τ_


Let

_Uk_ =[.] E∥B(z[k]) − _wn[k]+1[∥][2]_ _Wk_ =[.] _τ_

so that


E _yi[k]_ _i_
_i=1_ _∥_ _[−]_ _[w][k][∥][2][ +][ τ][ −][1]_

X


E _z[k]_ _x[k]i_
_i=1_ _∥_ _−_ _[∥][2][,]_

X


_ρETk = ρUk + Wk,_

_Vk_ =[.] E∥p[k] _−_ _p[∗]∥[2]._


and also let


-----

Using these definitions in (59) we write


_Vk+1 ≤_ (1 + C1α[2] + C3αρ[2])Vk − _αρUk −_ _αWk + C2α[2]_ + C4αρ[2].


Therefore,


_Vk+1 + αρUk + αWk ≤_ (1 + C1α[2] + C3αρ[2])Vk + C2α[2] + C4αρ[2]

_k_ _k_ _k−1_ _k−1_

_⇒_ _Vk+1 + αρ_ _j=1_ _Uj + α_ _j=1_ _Wj ≤_ (1 + C1α[2] + C3αρ[2])Vk + αρ _j=1_ _Uj + α_ _j=1_ _Wj_

X X X X

+ C2α[2] + C4αρ[2]


_k−1_

_Uj + α_
_j=1_

X


_k−1_

_Wj_
_j=1_

X


(1 + C1α[2] + C3αρ[2])
_≤_


_C1α[2]_ + C3αρ[2]) _Vk + αρ_





+ C2α[2] + C4αρ[2],


where we have used that Uk, Wk 0. Letting
_≥_

_Rk = Vk + αρ_

we then have


_k−1_

_Uj + α_
_j=1_

X


_k−1_

_Wj,_
_j=1_

X


_Rk+1 ≤_ (1 + C1α[2] + C3αρ[2])Rk + C2α[2] + C4αρ[2],


which implies


_Rk+1 ≤_ (1 + C1α[2] + C3αρ[2])[k]R1 + (C2α[2] + C4αρ[2])


(1 + C1α[2] + C3αρ[2])[k][−][j].
_j=1_

X


Now,

Therefore,


_k−1_

(1 + C1α[2] + C3αρ[2])[j]
_j=0_

X


(1 + C1α[2] + C3αρ[2])[k][−][j] =
_j=1_

X


= [(1 +][ C][1][α][2][ +][ C][3][αρ][2][)][k][ −] [1]

(1 + C1α[2] + C3αρ[2]) 1
_−_

= [(1 +][ C][1][α][2][ +][ C][3][αρ][2][)][k][ −] [1]

_C1α[2]_ + C3αρ[2]

_._

_≤_ [(1 +]C[ C]1α[1][α][2] [2]+[ +] C[ C]3αρ[3][αρ][2] [2][)][k]

_Rk+1_ (1 + C1α[2] + C3αρ[2])[k] _R1 +_ _[C][2][α][2][ +][ C][4][αρ][2]_ _._
_≤_ _C1α[2]_ + C3αρ[2]
 


Fix the number of iterations K ≥ 1. Now

_ρ = min_ _K_ _[−][1][/][4],_ [1]

2L



Therefore,


_K_ [1][/][4][ ≤] [1][.]


(Uj + Wj) ≤ _αρ_
_j=1_

X


_αρ_


_Uj + α_ _Wj_
_j=1_ _j=1_

X X


_RK+1_
_≤_

(1 + C1α[2] + C3αρ[2])[K] _R1 +_ _[C][2][α][2][ +][ C][4][αρ][2]_
_≤_ _C1α[2]_ + C3αρ[2]



-----

Dividing through by αρK, we obtain

_K_

1

(Uj + Wj)

_K_ _≤_ [(1 +][ C][1][α]αρK[2][ +][ C][3][αρ][2][)][K]

_j=1_

X

and since α = Cf _ρ[2], we also have_


_R1 +_ _[C][2][α][2][ +][ C][4][αρ][2]_

_C1α[2]_ + C3αρ[2]


(60)

(61)


_C2α[2]_ + C4αρ[2]

_C1α[2]_ + C3αρ[2][ =][ C]C[f]f _[C]C[2]1[ +] +[ C] C[4]3_


Furthermore,

_ρ_ _K_ _[−]_ 4[1] = _α_ _Cf_ _K_ _[−]_ 2[1] .
_≤_ _⇒_ _≤_

Substituting these into (60) yields


_K_



1 + _[C][f][ (][C][f]K[ C][1][+][C][3][)]_

_αρK_


_R1 +_ _[C][f]_ _[C][2][ +][ C][4]_

_Cf_ _C1 + C3_

_R1 +_ _[C][f]_ _[C][2][ +][ C][4]_

_Cf_ _C1 + C3_


(Uj + Wj) ≤
_j=1_

X


_≤_ [exp(][C][f] [(]αρK[C][f] _[C][1][ +][ C][3][))]_


where we have used that for any t ≥ 0, 1 + t/K ≤ _e[t/K], so therefore (1 + t/K)[K]_ _≤_ _e[t]._

The worst-case rates in terms of K occur when ρ = K _[−][1][/][4]_ and α = Cf _K_ _[−][1][/][2]. This is the case_
when K ≥ (2L)[4]. Substituting these into the denominator yields, for K ≥ (2L)[4], that


_K_

1

(Uj + Wj)

_K_ _≤_ [exp(][C][f]C[(][C]f _K[f]_ _[C][1][/][1][4][ +][ C][3][))]_

_j=1_

X

Thus, since Gk ≤ max{τ, τ _[−][1]} (Uk + Wk), we obtain_

_K_

1

E[Gj]

_K_ _≤_ [max][{][τ, τ][ −][1][}][ exp (]Cf _K[C][1][/][f][4][(][C][f]_ _[C][1][ +][ C][3][))]_

_j=1_

X

which is (58).


_R1 +_ _[C][f]_ _[C][2][ +][ C][4]_ _._

_Cf_ _C1 + C3_



_p[1]_ _p[∗]_ + _[C][f]_ _[C][2][ +][ C][4]_
_∥_ _−_ _∥[2]_ _Cf_ _C1 + C3_


When K < (2L)[4], (57) can similarly be obtained by substituting ρ = (2L)[−][1] and α = Cf (2L)[−][2]
into (61).

F APPROXIMATION RESIDUALS

In this section we derive the approximation residual used to assess the performance of the algorithms
in the numerical experiments. This residual relies on the following product-space reformulation
of (1).

F.1 PRODUCT-SPACE REFORMULATION AND RESIDUAL PRINCIPLE

Recall (1), the monotone inclusion we are solving:


Find z ∈ R[d] : 0 ∈


_Ai(z) + B(z)._
_i=1_

X


In this section we demonstrate a “product-space" reformulation of (1) which allows us to rewrite
it in a standard form involving just two operators, one maximal monotone and the other monotone
and Lipschitz. This approach was pioneered in (Briceño-Arias & Combettes, 2011; Combettes &
Pesquet, 2012). Along with allowing for a simple definition of an approximation residual as a measure
of approximation error in solving (1), it allows one to apply operator splitting methods originally
formulated for two operators to problems such as (1) for any finite n.


-----

Observe that solving (1) is equivalent to

Find (w1, . . ., wn, z) ∈ R[(][n][+1)][d] : _wi ∈_ _Ani(z),_ _i ∈_ 1..n


0 ∈


_wi + B(z)._
_i=1_

X


This formulation resembles that of the extended solution set S used in projective spitting, as given
in (5), except that it combines the final two conditions in the definition of S, and thus does not need
the final dual variable wn+1. From the definition of the inverse of an operator, the above formulation
is equivalent to

Find (w1, . . ., wn, z) ∈ R[(][n][+1)][d] : 0 ∈ _A[−]i_ [1][(][w][i][)][ −] _[z,]_ _i ∈_ 1..n


0 ∈


_wi + B(z)._
_i=1_

X


These conditions are in turn equivalent to finding (w1, . . ., wn, z) ∈ R[(][n][+1)][d] such that

0 _A (w1, . . ., wn, z) + B(w1, . . ., wn, z),_ (62)
_∈_

where A is the set-valued map

_A (w1, . . ., wn, z) 7→_ _A[−]1_ [1][(][w][1][)][ ×][ A]2[−][1][(][w][2][)][ ×][ . . .][ ×][ A]n[−][1][(][w][n][)][ × {][0][}] (63)

and B is the single-valued operator

0 0 _I_ _w1_ 0

_· · ·_ _−_
. . . . .

_B(w1, . . ., wn, z)_  .. ... .. ..   ..   ..  (64)
_7→_ 0 0 _I_ _wn_ 0

 _I_ _· · ·_ _I_ _−0_   _z_   _B(z)_ 
 _· · ·_     
    [+]   _[.]_

It is easily established that B is maximal monotone and Lipschitz continuous, while A is maximal
_._
monotone. Letting T = A + B, it follows from (Bauschke & Combettes, 2017, Proposition
20.23) that T is maximal monotone. Thus, we have reformulated (1) as the monotone inclusion
0 ∈ _T (q) for q in the product space R[(][n][+1)][d]. A vector z ∈_ R[d] solves (1) if and only if there exists
(w1, . . ., wn) ∈ R[nd] such that 0 ∈ _T (q), where q = (w1, . . ., wn, z)._

For any pair (q, v) such that v ∈ _T (q), ∥v∥[2]_ represents an approximation residual for q in the sense
that v = 0 implies q is a solution to (62). One may take ∥v∥[2] as a measure of the error of q as an
approximate solution to (62), and it can only be 0 if q is a solution. Given two approximate solutions
_qsolution than1 and q2 with certificates q2 if ∥v1∥[2]_ _< v1 ∥ ∈v2T∥[2](. Doing so is somewhat analogous to the practice, common inq1) and v2 ∈_ _T (q2), we will treat q1 as a “better” approximate_
optimization, of using the gradient ∥∇f (x)∥[2] as a measure of quality of an approximate minimizer
of some differentiable function f . However, note that since T (q1) is a set, there may exist elements
of T (q1) with smaller norm than v1. Thus any given certificate v1 only corresponds to an upper
bound on dist[2](0, T (q1)).

F.2 APPROXIMATION RESIDUAL FOR PROJECTIVE SPLITTING


In SPS (Algorithm 1), forseen from the definition of the resolvent. Thus i ∈ 1..n, the pairs ( xx[k]i[k]i[, y][∈]i[k][A][)][ are chosen so that]i[−][1][(][y]i[k][)][. Observe that][ y]i[k] _[∈]_ _[A][i][(][x]i[k][)][. This can be]_

_x[k]1_

_[−]._ _[z][k]_
.

_v[k][ .]=_  .  1 _[, . . ., y]n[k][, z][k][)][.]_ (65)

_x[k]n_

 
 _B(z[k]) +[−]_ _[z]i[k]=1_ _[y]i[k]_ 
 
  _[∈]_ _[T][ (][y][k]_

The approximation residual for SPS is thus

_n_ [P][n] _n_

_Rk_ =[.] _v[k]_ = _z[k]_ _x[k]i_ _B(z[k]) +_ _yi[k]_ (66)
_∥_ _∥[2]_ _i=1_ _∥_ _−_ _[∥][2][ +]_ _i=1_

X X

[2]


-----

which is an approximation residual for (y1[k][, . . ., y]n[k][, z][k][)][ in the sense defined above. We may relate]
_Rk to the approximation residual Gk for SPS from Section 5 as follows:_


_z[k]_ _x[k]i_ _yi[k]_
_i=1_ _∥_ _−_ _[∥][2][ +]_ _i=1_

X X 2

_n_ _n_ _n+1_

_[B][(][z][k][) +]_

_z[k]_ _x[k]i_ _yi[k]_ _wi[k]_
_i=1_ _∥_ _−_ _[∥][2][ +]_ _i=1_ _[−]_ _i=1_

X X X

_n_ _n_

_i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ + 2][∥][B][B][(][z][(][z][k][k][) +][)][ −]_ _[w]n[k]+1[∥][2][ + 2]_ _i=1(yi[k]_ _[−]_ _[w]i[k][)]_

X X


_Rk =_


_i=1_ _∥z[k]_ _−_ _x[k]i_ _[∥][2][ + 2][∥][B][(][z][k][)][ −]_ _[w]n[k]+1[∥][2][ + 2][n]_

X


_yi[k]_ _i_

_[−]_ _[w][k]_


_i=1_


2nGk
_≤_

where in the second equality we have used the fact that _i=1_ _[w]i[k]_ [= 0][. Thus,][ R][k][ has the same]
convergence rate as Gk given in Theorem 2.

Note that while the certificate given in (65) focuses on the primal iterate[P][n][+1] _z[k], it may be changed to_
focus on any x[k]i [for][ i][ = 1][, . . ., n][, by using]

_x[k]1_ _i_

_[−]._ _[x][k]_

_vi[k]_ =.  ..  1 _[, . . ., y]n[k][, x]i[k][)][.]_

_x[k]n_ _i_

 
 _B(x[k]i_ [) +][−][ P][x]i[n][k]=1 _[y]i[k]_ 
 
  _[∈]_ _[T][ (][y][k]_

The approximation residual _vi[k]_
similar derivations to those above for ∥ _[∥][2][ may also be shown to have the same rate as] Rk._ _[ G][k][ by following]_


F.3 TSENG’S METHOD

Tseng’s method (Tseng, 2000) can be applied to (62), resulting in the following recursion with iterates
_q[k], ¯q[k]_ _∈_ R[(][n][+1)][d]:

_q¯[k]_ = JαA (q[k] _−_ _αB(q[k]))_ (67)

_q[k][+1]_ = ¯q[k] + α _B(q[k]) −_ _B(¯q[k])_ _,_ (68)

where A and B are defined in (63) and (64). The resolvent of  _A may be readily computed from the_
resolvents of the Ai using Moreau’s identity (Bauschke & Combettes, 2017, Proposition 23.20).

Analogous to SPS, Tseng’s method has an approximation residual, which in this case is an element of
_T (¯q[k]). In particular, using the general properties of resolvent operators as applied to JαA, we have_
1

_q[k])_ _B(q[k])_ _A (¯q[k])._
_α_ [(][q][k][ −] [¯] _−_ _∈_

Also, rearranging (68) produces
1

_q[k]_ _q[k][+1]) + B(q[k]) = B(¯q[k])._
_α_ [(¯] _−_

Adding these two relations produces
1

_q[k]) + B(¯q[k]) = T (¯q[k])_
_α_ [(][q][k][ −] _[q][k][+1][)][ ∈]_ _[A][ (¯]_

Therefore,

_._
_Rk[Tseng]_ = α[1][2][ ∥][q][k][ −] _[q][k][+1][∥][2]_

represents a measure of the approximation error for Tseng’s method equivalent to Rk defined in (66)
for SPS.


-----

F.4 FRB

The forward-reflected-backward method (FRB) (Malitsky & Tam, 2020) is another method that may
be applied to the splitting T = A + B for A and B as defined in (63) and (64). Doing so yields
recursion

_q[k][+1]_ = JαA _q[k]_ _α_ 2B(q[k]) _B(q[k][−][1])_ _._
_−_ _−_

Following similar arguments to those for Tseng’s method, it can be shown that   []

_._
_vFRB[k]_ = [1] _q[k][−][1]_ _q[k][]_ + B(q[k]) + B(q[k][−][2]) 2B(q[k][−][1]) _T (q[k])._

_α_ _−_ _−_ _∈_

Thus, FRB admits the following approximation residual equivalent to  _Rk for SPS:_

_._
_Rk[FRB]_ = ∥vFRB[k] _[∥][2][.]_

Finally, we remark that the stepsizes used in both the Tseng and FRB methods can be chosen via a
linesearch procedure that we do not detail here.

F.5 STOCHASTIC TSENG METHOD

The stochastic version of Tseng’s method of (Böhm et al., 2020) (S-Tseng) may be applied to the
inclusion 0 ∈ _A (q) + B(q), since the operator A may be written as a subdifferential. However,_
unlike the deterministic Tseng method, it does not produce a valid residual. Note also that S-Tseng
outputs an ergodic sequence qerg[k] [. To construct a residual for the ergodic sequence, we compute a]
deterministic step of Tseng’s method according to (67)-(68), starting at qerg[k] [. That is, letting]


_q¯[k]_ = JαA (qerg[k] erg[))]

_[−]_ _[B][(][q][k]_

_q[k][+1]_ = ¯q[k] + α(B(qerg[k] [)][ −] _[B][(¯]q[k])),_
we can then compute essentially the same residual as in Section F.3,

_Rk[S-Tseng]_ = . _α[1][2][ ∥][q]erg[k]_ _[−]_ _[q][k][+1][∥][2][.]_

To construct the stochastic oracle for S-Tseng, we assumed B(z) = _m[1]_


_m_
_i=1_ _[B][i][(][z][)][. Then we used]_

0

P





_· · ·_ 0 _−I_
. .
... .. ..

_· · ·_ 0 _−I_

_· · ·_ _I_ 0


_w1_
.
.
.
_wn_


(69)



 _[.]_


_B˜(w1, . . ., wn, z)_ .
_7→_ 0

 _I_



for some minibatch B ∈{1, . . ., m}.

F.6 VARIANCE-REDUCED FRB




 [+]


1

**B** _j_ **B** _[B][j][(][z][)]_
_|_ _|_ _∈_
P


The FRB-VR method of Alacaoglu et al. (2021) can also be applied to 0 ∈ _A (q) + B(q), using the_
same stochastic oracle _B[˜] defined in (69). if we let the iterates of FRB-VR be (q[k], p[k]), then line 4 of_
Algorithm 1 of Alacaoglu et al. (2021) can be written as

_qˆ[k]_ = q[k] _−_ _τ_ (B(p[k]) + B[˜](q[k]) − _B[˜](p[k]))_ (70)

_q[k][+1]_ = Jτ _A (ˆq[k])._ (71)


Once again, the method does not directly produce a residual, but one can be developed from the
algorithm definition as follows: (71) yields τ _[−][1](ˆq[k]_ _−_ _q[k][+1]) ∈_ _A (q[k][+1]) and hence_

_τ_ _[−][1](ˆq[k]_ _−_ _q[k][+1]) + B(q[k][+1]) ∈_ (A + B)(q[k][+1]).
Therefore we use the residual
_Rk[FRB-VR]_ = ∥τ _[−][1](ˆq[k]_ _−_ _q[k][+1]) + B(q[k][+1])∥[2]._

Figure 1 plots Rk for SPS, Rk[Tseng] for Tseng’s method, Rk[FRB] for FRB, Rk[S-Tseng] for S-Tseng, and
_Rk[FRB-VR]_ for FRB-VR.


-----

F.7 BENEFITS AND DRAWBACKS OF THE PRODUCT SPACE REFORMULATION

The main benefit of the product space reformulation (PSR) is that it allows one to use familiar
2-operator splitting schemes for solving 0 ∈ _A (q) + B(q) to solve the more complicated recursion_
(1). However, one drawback of this approach is that the operator B, defined in (64), combines a
skew-symmetric consensus matrix with the Lipschitz operator B. Treating B as a single operator
necessitates using a single stepsize for both of its constituent operators, but the B component will
generally have a much larger Lipschitz constant than the skew part, necessitating a smaller stepsize
than is ideal for the skew operator. This difficulty can be countered by using different stepsizes
for the primal and dual components, but that strategy introduces additional tuning parameters. In
other works, methods based on PSR have exhibited slower convergence than deterministic projective
splitting methods (Johnstone & Eckstein, 2021; 2020b). However, in our experiments in Section 7,
the performance is comparable.

G VARIATIONAL INEQUALITIES

For a mapping B : R[d] _→_ R[d] and a closed and convex set C, the variational inequality problem
(Harker & Pang, 1990) is to find z[∗] _∈C such that_
_B(z[∗])[⊤](z −_ _z[∗]) ≥_ 0, ∀z ∈C. (72)
Consider the normal cone mapping discussed in Section 2 and defined as
_N_ (x) =[.] _g : g[⊤](y_ _x)_ 0 _y_
_C_ _{_ _−_ _≤_ _∀_ _∈C}_
It is easily seen that (72) is equivalent to finding z[∗] such that _B(z[∗])_ _N_ (z[∗]). Hence, if B is
_−_ _∈_ _C_
monotone, (72) is equivalent to the monotone inclusion
0 _B(z[∗]) + N_ (z[∗]). (73)
_∈_ _C_
Thus, monotone variational inequalities are a special case of monotone inclusions with two operators,
one of which is single-valued and the other is the normal cone map of the constraint set C. As a
consequence, methods for monotone inclusions can be used to solve monotone variational inequality
problems. The reverse, however, may not be true. For example, the analysis of the extragradient
method (Korpelevich, 1977) relies on the second operator N in (73) being a normal cone, as opposed
_C_
to a more general monotone operator. We are not aware of any direct extension of the extragradient
method’s analysis allowing a more general resolvent to be used in place of the projection map
corresponding to N .
_C_

**The Restricted Gap Function** There is a disadvantage to pursuing convergence rates based on
variational inequalities (as in Böhm et al. (2020) and Alacaoglu et al. (2021)) rather than monotone
inclusions. Convergence rate analyses for variational inequalities focus on the gap function:
_G_ (z) = sup[.] _B(z[′])[⊤](z_ _z[′])._ (74)
_C_ _z[′]∈C_ _−_

It can be shown that G (z) 0 and G (z) = 0 if and only if z solves (72). However, (74) is
_C_ _≥_ _C_
meaningless for most problems, since unless is compact, G (z) is typically equal to + for any
_C_ _C_ _∞_
nonsolution (Diakonikolas, 2020). Thus researchers instead focus on the restricted gap function
(Nesterov, 2007)
_GC2_ (z) = sup[.] _z[′]∈C2_ _B(z[′])[⊤](z −_ _z[′])._ (75)

where C2 is an arbitrary compact set. However, now the results are only meaningful over the set C2.
Thus, C2 must be chosen large enough so that the iterates of the algorithm remain in the interior of
_C2 (Böhm et al., 2020). Further, the convergence rate bound depends on the diameter of C2. For_
some algorithms (Mokhtari et al., 2020) a valid set is provided which bounds the iterates. However
Böhm et al. (2020) and Alacaoglu et al. (2021) do not provide one, although in principle it could be
done so long as the ergodic sequence can be bounded almost-surely. Thus, the convergence rates
depending on (75) in Böhm et al. (2020) and Alacaoglu et al. (2021) are somewhat incomplete in that
they depend on unknown constants.

In contrast, rates based on the approximation residual in the monotone inclusion setting, including
ours given in (57)–(58), completely avoid this pitfall. There is no need to select a compact set
containing the algorithm’s iterates and the constants in our rates are all explicit or depend on standard
quantities such as the initial distance to a solution.


-----

H MEMORY-SAVING TECHNIQUE FOR SPS

The variables t[k]i [,][ x]i[k][, and][ y]i[k] [on lines 3-5 of SPS are stored in variables][ t, x][ and][ y][. Another two]
variables ¯x and ¯y keep track of _i=1_ _[x]i[k]_ [and][ P]i[n]=1 _[y]i[k][. The dual variables are stored as][ w][i][ for]_
_i ∈_ 1..n and the primal variable as z. Once x = x[k]i [is computed, the][ i][th][ dual variable][ w][i][ can be]
partially updated as wi _wi_ _αk[P]x. Once all the operators have been processed, the update for each[n]_
dual variable may be completed viaas z _z_ _αky¯. During the calculation loop for the ←_ _−_ _wi ←_ _wi + αk(n x + 1)[k]i_ _[, y]i[k][−][, the terms in approximation residual][1]x¯. Also, the primal update is computed[ R][k]_
_←_ _−_
may also be accumulated one by one. The total total number of vector elements that must be stored is
(n + 7)d.

I ADDITIONAL INFORMATION ABOUT THE NUMERICAL EXPERIMENTS

We solve the following convex-concave min-max problem:


_λ(δ_ _κ) + [1]_
_−_ _m_


_m_

Ψ( _xˆi, β_ ) + [1]
_⟨_ _⟩_ _m_
_i=1_

X


_γi(ˆyi_ _xˆi, β_ _λκ) + c_ _β_ 1
_⟨_ _⟩−_ _∥_ _∥_
_i=1_

X


min
_βλ∈∈RR[d]_


max
_γ∈R[m]_


(76)


s.t. _β_ 2 _λ/(LΨ + 1)_ _γ_ 1.
_∥_ _∥_ _≤_ _∥_ _∥∞_ _≤_

This model is identical to that of (Yu et al., 2021, Thm. 4.3) except for the addition of the ℓ1
regularization term c _β_ 1, where c 0 is a given constant. The goal is to learn the model weights β
_∥_ _∥_ _≥_
from a training dataset of m feature vectors ˆxi and corresponding labels ˆyi. Rather than computing
the expected loss over the training set, the formulation uses, for each β, the worst possible distribution
within a Wasserstein-metric ball around the empirical distribution of the (ˆxi, ˆyi), with the parameter
_{_ _}_
_δ ≥_ 0 giving the diameter of the ball and the parameter κ ≥ 0 specifying the relative weighting of
features and labels. The variables γ and λ parameterize the selection of this worst-case distribution in
response to the model weights β. Finally, Ψ is the logistic loss kernel t 7→ log(e[t] + e[−][t]) and LΨ = 1
is the corresponding Lipschitz constant. In all the experiments, we set δ = κ = 1 and c = 10[−][3].

We now show how we converted this problem to the form (1) for our experiments. Let z be a
shorthand for (λ, β, γ), and define


(z) =[.] _λ(δ_ _κ) + [1]_
_L_ _−_ _m_


_m_

Ψ( _xˆi, β_ ) + [1]
_⟨_ _⟩_ _m_
_i=1_

X


_γi(ˆyi_ _xˆi, β_ _λκ)._
_⟨_ _⟩−_
_i=1_

X


The first-order necessary and sufficient conditions for the convex-concave saddlepoint problem in
(76) are

0 _B(z) + A1(z) + A2(z)_ (77)
_∈_

where the vector field B(z) is defined as


_λ,β_ (z)
_∇_ _L_

_γ_ (z)
_−∇_ _L_


_B(z)_ =[.]


(78)


with

and


_mi=1_ _δ[Ψ] −[′][(][⟨]κx[ˆ](1 +i, β⟩)ˆmx[1]_ _i +Pmim=1[1]_ _[γ][i]mi[)]=1_ _[γ][i]y[ˆ]ixˆi_
P P


_λ,β_ (z) =
_∇_ _L_


_m1_ [(ˆ]y1⟨xˆ1, β⟩− _λκ)_
.

_∇γL(z) =_  .. 

 _m1_ [(ˆ]ym _xˆm, β_ _λκ)_ 
 _⟨_ _⟩−_ 
  _[.]_

It is readily confirmed that B defined in this manner is Lipschitz. The monotonicity of B follows
from its being the generalized gradient of a convex-concave saddle function (Rockafellar, 1970).


-----

For the set-valued operators, A1(z) corresponds to the constraints and A2(z) to the nonsmooth ℓ1
regularizer, and are defined as


_A1(z)_ =[.] _NC1_ (λ, β) × NC2 (γ),

1 =[.] (λ, β) : _β_ 2 _λ/(LΨ + 1)_ and 2 =[.] _γ :_ _γ_ 1 _,_
_C_ _∥_ _∥_ _≤_ _C_ _{_ _∥_ _∥∞_ _≤_ _}_



where

and


_A2(z)_ =[.] _{01×1} × c∂∥β∥1 × {0m×1}._

Here, the notation 0p 1 denotes the p-dimensional vector of all zeros. 1 is a scaled version of
_×_ _C_
the second-order cone, well known to be a closed convex set, while 2 is the unit ball of the ℓ
_C_ _∞_
norm, also closed and convex. Since A1 is a normal cone map of a closed convex set and A2 is the
subgradient map of a closed proper convex function (the scaled 1-norm), both of these operators are
maximal monotone and problem (77) is a special case of (1) for n = 2.

**Stochastic oracle implementation** The operator B : R[m][+][d][+1] _7→_ R[m][+][d][+1], defined in (78), can
be written as


_B(z) = [1]_


_Bi(z)_
_i=1_

X


where


_δ_ _κ(1 + γi)_
_−_

Ψ[′](⟨xˆi, β⟩)ˆxi + γiyˆixˆi
**0(i−1)×1**
(ˆyi _xˆi, β_ _λκ)_
_−_ _⟨_ _⟩−_

**0(m−i)×1**


_Bi(z)_ =[.]


In our SPS experiments, the stochastic oracle for B is simply _B[˜](z) =_ **B1** _i_ **B** _[B][i][(][z][)][ for some]_

_|_ _|_ _∈_
minibatch B 1, . . ., m . We used a batchsize of 100.
_⊆{_ _}_ P

**Resolvent computations** The resolvent of A1 is readily constructed from the projection maps of
the simple sets C1 and C2, while the resolvent A2 involves the proximal operator of the ℓ1 norm.
Specifically,


**01×1**
proxρc∥·∥1(β)

**0m×1**


projC1(λ, β)

projC2(γ)


and _JρA2_ (z) =


_JρA1_ (z) = " projC1C2(γ) # and _JρA2_ (z) = prox0ρcm∥·∥11(β) _._

 _×_ 
 

The constraint 1 is a scaled second-order cone and 2 is the ℓ ball, both of which have closed-form
_C_ _C_ _∞_
projections. The proximal operator of the ℓ1 norm is the well-known soft-thresholding operator
(Parikh & Boyd, 2013, Section 6.5.2). Therefore all resolvents in the formulation may be computed
quickly and accurately.

**SPS stepsize choicesLipschitz constant L of BFor the stepsize in SPS, we ordinarily require. However, since the global Lipschitz constant may be pessimistic, better ρk ≤** _ρ < 1/L for the global_
performance can often be achieved by experimenting with larger stepsizes. If divergence is observed,
then the stepsize can be decreased. This type of strategy is common for SGD and similar stochastic
methods. Thus, for SPS-decay we set αk = Cdk[−][0][.][51] and ρk = Cdk[−][0][.][25], and performed a grid
search to select the best Cd from {0.1, 0.5, 1, 5, 10}, arriving at Cd = 1 for epsilon and SUSY, and
_Cd = 0.5 for real-sim. For SPS-fixed we used ρ = K_ _[−][1][/][4]_ and α = Cf _ρ[2], and performed a grid_
search to select Cf over {0.1, 0.5, 1, 5, 10}, arriving at Cf = 1 for epsilon and real-sim, and Cf = 5
for SUSY. The total number of iterations for SPS-fixed was chosen as follows: For the epsilon dataset,
we used K = 5000, for SUSY we used K = 200, and for real-sim we used K = 1000.


_JρA1_ (z) =


-----

Figure 2: Approximation residual versus epoch for three LIBSVM benchmark datasets. Left: epsilon,
middle: SUSY, right: real-sim.

**Parameter choices for the other algorithms** All methods are initialized at the same random point.
For Tseng’s method, we used the backtracking linesearch variant with an initial stepsize of 1, θ = 0.8,
and a stepsize reduction factor of 0.7. For FRB, we used the backtracking linesearch variant with the
same settings as for Tseng’s method. For deterministic PS, we used a fixed stepsize of 0.9/L. For
the stochastic Tseng’s method of Böhm et al. (2020), the stepsize αk must satisfy: _k=1_ _[α][k][ =][ ∞]_
and _k=1_ _[α]k[2]_ _[<][ ∞][. So we set][ α][k][ =][ Ck][−][d][ and perform a grid search over][ {][C, d][}][ in the range]_

[10[−][4], 10] [0.51, 1], checking 5 5 values to find the best setting for each of the three problems.[P][∞]
_×_ _×_
The selected values are in Table 1.

[P][∞]

epsilon SUSY real-sim

_C_ 0.56 0.56 0.77

_d_ 0.6 0.6 0.55

Table 1: Parameter Values for S-Tseng

The work of Böhm et al. (2020) also introduced FBFp, a stochastic version of Tseng’s method that
reuses a previously-computed gradient and therefore only needs one additional gradient calculation
per iteration. In our experiments, the performance of the two methods was about the same, so we
only report the performance of stoch. Tseng’s method.

For variance-reduced FRB, the main parameter is the probability p. We hand-tuned p,arriving at
_p = 0.01 for all problems. We set the stepsize to its maximum allowed value of_

_τ = [1][ −√][1][ −]_ _[p]_ _._

2L

**Plots versus Epoch** Figure 2 plots the performance of each method versus epoch (i.e. data pass).
This shows an even more dramatic benefit for the stochastic methods than the plots versus time,
since at each iteration the stochastic methods only need to process small amounts of data, whereas
deterministic methods must process all of it. We believe these benefits do not fully manifest
themselves in the plots versus time due to overheads in each iteration of the stochastic methods,
multithreading providing a boost for the deterministic methods, memory access patterns, and other
practical considerations.

**Fraction of Nonzero Entries versus Running time** Figure 3 plots the fraction of nonzero entries
in the iterates of each method versus running time. For each method, we used output of proxc∥·∥1.
We observe that our methods produce sparse intermediate iterates for two of the three problems. This
is one of the benefits of proximal splitting algorithms in general, including our method. For the other
problem, SUSY, no method produces sparse iterates, suggesting that c should be increased if sparse
solutions are desired.


-----

Figure 3: Fraction of nonzero entries versus running time for the three datasets. Left: epsilon, middle:
SUSY, right: real-sim.

J LOCAL CONVERGENCE ON NON-MONOTONE PROBLEMS

The work by Hsieh et al. (2020) provides a local convergence analysis for DSEG applied to locally
monotone problems. Recall that DSEG is equivalent to the special case of SPS for which n = 0.
While extending this result to the more general setting of SPS is beyond the scope of this manuscript,
we next provide a preliminary sketch of how the analysis of Hsieh et al. (2020) might be generalized
to our setting. We leave a formal proof to future work.

**Sketch of assumptions and main result** The first assumption needed is the existence of an isolated
solution p[∗] = (z[∗], w1[∗][, . . ., w]n[∗]+1[)][ ∈S][. We then require that there exists a ball][ B][r][(][z][∗][)][, centered at]
_z[∗], throughout which the operator B is “well-behaved”, meaning that it satisfies monotonicity and_
Lipschitz continuity. In addition, we need each Ai, for i 1..n, to be maximal monotone within this
_∈_
ball. Outside of the ball, the operators do not need to be monotone or Lipschitz.

Following (Hsieh et al., 2020, Assumption 2[′]), the noise variance assumptions are slightly stronger
than in the monotone case. In particular, we require that E[∥ϵ[k]∥[q]|Fk] ≤ _N_ _[q]_ and E[∥e[k]∥[q]|Fk] ≤ _N_ _[q]_
for some q > 2. As before, the noise must be zero-mean. Finally, the stepsize requirements are also
slightly stronger than (12), having the added assumption that _k=1_ _[ρ]k[q]_ _[<][ ∞][.]_

With these assumptions, the goal is to show that, so long as the initial point p[1] is sufficiently close to
_p[∗], then with high probability p[k]_ converges to p[∗]. [P][∞]

**Proof strategy** The initial strategy is to develop the following recursion, satisfied by SPS, that does
not (yet) utilize local monotonicity or Lipschitz continuity:

_p[k][+1]_ _p[∗]_ (1 + c1αk[2][)][∥][p][k][ −] _[p][∗][∥][2][ −]_ _[c][2][α][k][ρ][k][(][T][ ′]k_ [+][ l][k] [+][ r][k][)][ −] _[c][3][α][k][(][r]k[′]_ [+][ q][k][)]
_∥_ _−_ _∥[2]_ _≤_

+ c1αk[2] _e[k]_ + _ϵ[k]_ + c4 + c5αkqk[′] (79)
_∥_ _∥[2]_ _∥_ _∥[2]_

for appropriate constants c1 . . . c5 ≥  0. In this inequality, we use


_._
_Tk[′]_ = _[τ]ρ_


_n_

_i=1_ _∥yi[k]_ _[−]_ _[w]i[k][∥][2][ + 1]ρτ_

X


_z[k]_ _x[k]i_
_i=1_ _∥_ _−_ _[∥][2][,]_

X


_lk_ =[.] _i=1⟨z[∗]_ _−_ _x[k]i_ _[, w]i[∗]_ _[−]_ _[y]i[k][⟩]_ [+] _z[∗]_ _−_ _x[k]n+1[, w]i[∗]_ _[−]_ _[B][(][x]n[k]+1[)]_ _,_

X

_rk_ =[.] _⟨ϵ[k], B(˜x[k]) −_ _wn[k]+1[⟩][,]_

_._
_rk[′]_ = _z[k]_ _z[∗], e[k]_ _,_
_⟨_ _−_ _⟩_

_qk_ = ([.] _ρ[−]k_ [1] _d/2)_ _x˜[k]_ _z[k]_ _x˜[k]_ _z[k]_ _B(˜x[k])_ _B(z[k])_
_−_ _∥_ _−_ _∥[2]_ _−∥_ _−_ _∥∥_ _−_ _∥_

_._
_qk[′]_ = ρk∥ϵ[k]∥∥Bx[k]n+1 _[−]_ _[B]x[˜][k]∥_ + 2[1]d _[∥][B]x[˜][k]n+1_ _[−]_ _[Bx]n[k]+1[∥][2][,]_


where


_x˜[k][ .]= z[k]_ _−_ _ρk_ _B(z[k]) −_ _wn[k]+1_ _d = [.]_ 1 +[1][ −] ρ/[ρL]2 _[,]_ (80)
  


-----

with L being the local Lipschitz constant of B on Br(z[∗]). The iterate ˜x[k] is the analog of the iterate
_X˜t+1/2 used in Hsieh et al. (2020)._

The recursion (79) is derived by once again starting from (13) and following the arguments leading to
(35), but this time not taking conditional expectations. In particular, the upper bounds on _zϕk_
_∥∇_ _∥[2]_

and ∥∇wi _ϕk∥[2]_ contribute the terms c1αk[2] _∥e[k]∥[2]_ + ∥ϵ[k]∥[2] + c4) and c1αk[2][∥][p][k][ −] _[p][∗][∥][2][. For][ i][ ∈]_ [1][..n][,]
the “ϕi,k-gap" term, ϕi,k(p[k]) _ϕi,k(p[∗]), is dealt with in a similar manner to Section C.5, but this_
_−_  
time not using monotonicity as in (36). This contributes Tk[′] [and the first term in][ l][k][. Finally, as we]
sketch below, the “ϕn+1,k-gap" term contributes rk, rk[′] [,][ q][k][,][ q]k[′] [, and the last term in][ l][k][.]

For the “ϕn+1,k-gap”, that is, ϕn+1,k(p[k]) _ϕn+1,k(p[∗]), we have to depart from the analysis in_
_−_
Section C.6 and use an alternative argument involving ˜x[k]. We now provide some details of this
argument: in the following, we use Bz as shorthand for B(z) for any vector z ∈ R[d]. We begin the
analysis with

_ϕn+1,k(p[k]) = ⟨z[k]_ _−_ _x[k]n+1[, y]n[k]+1_ _[−]_ _[w]n[k]+1[⟩]_

= ⟨z[k] _−_ _x[k]n+1[, Bx][k]n+1_ _[−]_ _[w]n[k]+1[⟩]_ [+][ ⟨][z][k][ −] _[x][k]n+1[, e][k][⟩]_ _._ (81)
part of rk[′]
| {z }

The final term will combine with the term _x[k]n+1_
_⟨_ _[−]_ _[z][∗][, e][k][⟩]_ [coming from]

_−ϕn+1,k(p[∗]) = ⟨z[∗]_ _−_ _x[k]n+1[, w]n[∗]+1_ _[−]_ _[y]n[k]+1[⟩]_

= ⟨z[∗] _−_ _x[k]n+1[, w]n[∗]+1_ _[−]_ _[Bx]n[k]+1[⟩]_ [+][ ⟨][x]n[k]+1 _[−]_ _[z][∗][, e]n[k]+1[⟩]_ (82)

to yield rk[′] [above. Equation][ (82)][ also yields the second term in][ l][k][. Using that][ ˜]x[k] _−_ _x[k]n+1_ [=][ ρ][k][ϵ][k][, we]
rewrite the first term in (81) as

_⟨z[k]_ _−_ _x[k]n+1[, Bx]n[k]+1_ _[−]_ _[w]n[k]+1[⟩]_ [=][ ⟨][z][k][ −] _x[˜][k], Bx[k]n+1_ _[−]_ _[w]n[k]+1[⟩]_ [+][ ⟨]x[˜][k] _−_ _x[k]n+1[, Bx]n[k]+1_ _[−]_ _[w]n[k]+1[⟩]_

= _z[k]_ _x˜[k], Bx[k]n+1_ _n+1[⟩]_ [+][ ρ][k][⟨][ϵ][k][, Bx]n[k]+1 _n+1[⟩]_
_⟨_ _−_ _[−]_ _[w][k]_ _[−]_ _[w][k]_

= _z[k]_ _x˜[k], Bx[k]n+1_ _n+1[⟩]_ [+][ ρ][k][⟨][ϵ][k][, Bx]n[k]+1 _x[k]_ (83)
_⟨_ _−_ _[−]_ _[w][k]_ _[−]_ _[B]_ [˜] _⟩_

+ ρk ⟨ϵ[k], Bx˜[k] _−_ _wn[k]+1[⟩]_ _._
_rk_

Next, the terms in (83) admit the lower bound| {z }

_z[k]_ _x˜[k], Bx[k]n+1_ _n+1[⟩]_ [+][ ρ][k][⟨][ϵ][k][, Bx][k]n+1 _x[k]_
_⟨_ _−_ _[−]_ _[w][k]_ _[−]_ _[B]_ [˜] _⟩_

_z[k]_ _x˜[k], Bx[k]n+1_ _n+1[⟩−]_ _[ρ][k][∥][ϵ][k][∥∥][Bx][k]n+1_ _x[k]_ _._
_≥⟨_ _−_ _[−]_ _[w][k]_ _[−]_ _[B]_ [˜] _∥_
first part of qk[′]

Considering the first term on right-hand side of this bound, we also have| {z }


_z[k]_ _x˜[k], Bx[k]n+1_ _n+1[⟩]_ [=][ ⟨][z][k][ −] _x[˜][k], Bx˜[k]_ _wn[k]+1[⟩]_ [+][ ⟨][z][k][ −] _x[˜][k], Bx[k]n+1_ _x[k]_
_⟨_ _−_ _[−]_ _[w][k]_ _−_ _[−]_ _[B]_ [˜] _⟩_

_z[k]_ _x˜[k], Bx˜[k]_ _wn[k]+1[⟩−]_ _[d]_ _x[k]_ _x[k]_ _Bx[k]n+1[∥][2]_
_≥⟨_ _−_ _−_ 2 _[∥][z][k][ −]_ [˜] _∥[2]_ _−_ 2[1]d _[∥][B]_ [˜] _−_

second part of qk[′]

for any d > 0, using Young’s inequality. Finally, for the first two terms of the right-hand side of the| {z }
above relation, we may write

_z[k]_ _x˜[k], Bx˜[k]_ _wn[k]+1[⟩−]_ _[d]_ _x[k]_
_⟨_ _−_ _−_ 2 _[∥][z][k][ −]_ [˜] _∥[2]_


= _z[k]_ _x˜[k], Bz[k]_ _wn[k]+1[⟩]_ [+][ ⟨][z][k][ −] _x[˜][k], Bx˜[k]_ _Bz[k]_ _x[k]_
_⟨_ _−_ _−_ _−_ _⟩−_ _[d]2_ _[∥][z][k][ −]_ [˜] _∥[2]_

(ρ[−]k [1] _d/2)_ _z[k]_ _x˜[k]_ _z[k]_ _x˜[k]_ _Bx˜[k]_ _Bz[k]_
_≥_ _−_ _∥_ _−_ _∥[2]_ _−∥_ _−_ _∥∥_ _−_ _∥_
_qk_
| {z }


-----

where in the final inequality we use the Cauchy-Schwartz inequality and substitute Bz[k] _−_ _wn[k]+1_ [=]
_ρ[−]k_ [1][(][z][k][ −] _x[˜][k]), from the definition of ˜x[k]_ in (80). We have now accounted for all the terms appearing
in (79).

The recursion (79) is analogous to equation (F.7) on page 24 of Hsieh et al. (2020) and provides
the starting point for the local convergence analysis. The next step would be to derive an analog of
Theorem F.1. of Hsieh et al. (2020) using (79). The following translation to the notation of Theorem
F.1. could be used (note that Hsieh et al. (2020) uses t for iteration counter):

_Dk = ∥p[k]_ _−_ _p[∗]∥[2],_

_ζk = c2αkρk(Tk[′]_ [+][ l][k][) +][ c][3][α][k][q][k][,]

_ξk = −c2αkρkrk −_ _c3αkrk[′]_ _[,]_

_χk = c1αk[2]_ _∥e[k]∥[2]_ + ∥ϵ[k]∥[2] + ∥p[k] _−_ _p[∗]∥[2]_ + c4 + c5αkqk[′] _[,]_

and the event E[ρ]   
_∞_ [is translated to]

_E∞[ρ]_ [=] _x[k]n+1_ _[∈]_ [B][r][(][z][∗][)][,][ ˜]x[k] _∈_ Bρr(z[∗]), p[k] _∈_ Bρr(p[∗]) for all k = 1, 2, . . . _._

An analog of Theorem 2 of Hsieh et al. (2020) could then be developed based on this result.


-----

