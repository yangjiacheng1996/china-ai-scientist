# HOW DOES UNLABELED DATA IMPROVE GENERALIZA## TION IN SELF-TRAINING? A ONE-HIDDEN-LAYER THE- ORETICAL ANALYSIS


**Shuai Zhang**
Rensselaer Polytechnic Institute
Troy, NY, USA 12180
zhangs29@rpi.edu

**Sijia Liu**
Michigan State University
East Lansing, MI, USA 48824
MIT-IBM Watson AI Lab, IBM Research
liusiji5@msu.edu

**Jinjun Xiong**
University at Buffalo
Buffalo NY, USA 14260
jinjun@buffalo.edu


**Meng Wang**
Rensselaer Polytechnic Institute
Troy, NY, USA 12180
wangm7@rpi.edu

**Pin-Yu Chen**
IBM Research
Yorktown Heights, NY, USA 10562
Pin-Yu.Chen@ibm.com


ABSTRACT

Self-training, a semi-supervised learning algorithm, leverages a large amount of
unlabeled data to improve learning when the labeled data are limited. Despite empirical successes, its theoretical characterization remains elusive. To the best of
our knowledge, this work establishes the first theoretical analysis for the known
iterative self-training paradigm and proves the benefits of unlabeled data in both
training convergence and generalization ability. To make our theoretical analysis
feasible, we focus on the case of one-hidden-layer neural networks. However,
theoretical understanding of iterative self-training is non-trivial even for a shallow neural network. One of the key challenges is that existing neural network
landscape analysis built upon supervised learning no longer holds in the (semisupervised) self-training paradigm. We address this challenge and prove that iterative self-training converges linearly with both convergence rate and generalization
accuracy improved in the order of 1/√M, where M is the number of unlabeled

samples. Experiments from shallow neural networks to deep neural networks are
also provided to justify the correctness of our established theoretical insights on
self-training.

1 INTRODUCTION

Self-training (Scudder, 1965; Yarowsky, 1995; Lee et al., 2013; Han et al., 2019), one of the most
powerful semi-supervised learning (SemiSL) algorithms, augments a limited number of labeled data
with unlabeled data so as to achieve improved generalization performance on test data, compared
with the model trained by supervised learning using the labeled data only. Self-training has shown
empirical success in diversified applications such as few-shot image classification (Su et al., 2020;
Xie et al., 2020; Chen et al., 2020a; Yalniz et al., 2019; Zoph et al., 2020), objective detection
(Rosenberg et al., 2005), robustness-aware model training against adversarial attacks (Carmon et al.,
2019), continual lifelong learning (Lee et al., 2019), and natural language processing (He et al.,
2019; Kahn et al., 2020). The terminology “self-training” has been used to describe various SemiSL


-----

algorithms in the literature, while this paper is centered on the commonly-used iterative self-training
method in particular. In this setup, an initial teacher model (learned from the labeled data) is applied
to the unlabeled data to generate pseudo labels. One then trains a student model by minimizing the
weighted empirical risk of both the labeled and unlabeled data. The student model is then used as
the new teacher to update the pseudo labels of the unlabeled data. This process is repeated multiple
times to improve the eventual student model. We refer readers to Section 2 for algorithmic details.

Despite the empirical achievement of self-training methods with neural networks, the theoretical
justification of such success is very limited, even in the field of SemiSL. The majority of the theoretical results on general SemiSL are limited to linear networks (Chen et al., 2020b; Raghunathan
et al., 2020; Oymak & Gulcu, 2020; Oneto et al., 2011). The authors in (Balcan & Blum, 2010)
show that unlabeled data can improve the generalization bound if the unlabeled data distribution and
target model are compatible. For instance, the unlabeled data need to be well-chosen such that the
target function for labeled data can separate the unlabeled data clusters, which, however, may not be
able to be verified ahead. Moreover, (Rigollet, 2007; Singh et al., 2008) proves that unlabeled data
can improve the convergence rate and generalization error under a similar clustering assumption,
where the data contains clusters that have homogeneous labels. A recent work by Wei et al. (2020)
analyzes SemiSL on nonlinear neural networks and proves that an infinite number of unlabeled data
can improve the generalization compared with training with labeled data only. However, Wei et al.
(2020) considers single shot rather than iterative SemiSL, and the training problem aims to minimize
the consistency regularization rather than the risk function in the conventional self-training method
(Lee et al., 2013). Moreover, Wei et al. (2020) directly analyzes the global optimum of the nonconvex training problem without any discussion about how to achieve the global optimum. To the best
of our knowledge, there exists no analytical characterization of how the unlabeled data affect the
generalization of the learned model by iterative self-training on nonlinear neural networks.

**Contributions. This paper provides the first theoretical** 7
study of iterative self-training on nonlinear neural networks. Focusing on one-hidden-layer neural networks,
this paper provides a quantitative analysis of the generalization performance of iterative self-training as a
function of the number of labeled and unlabeled sam- 6
ples. Specifically, our contributions include Improvement (%)

**1.** **Quantitative justification of generalization im-**
**provement by unlabeled data.** Assuming the exis- 100K 200K 300K 400K 500K
tence of a ground-truth model with weights W _[∗]_ that Number of unlabeled data

7

6.5

6

Test accuracy

Improvement (%)

5.5

100K 200K 300K 400K 500K

Number of unlabeled data

maps the features to the corresponding labels, we prove
that the learned model via iterative self-training moves

Figure 1: The trend of test accuracy

closer to W _[∗]_ as the number M of unlabeled data in- improvement (%) on CIFAR-10 by selfcreases, indicating a better testing performance. Specif
training on CIFAR-10 (labeled) with dif
ically, we prove that the Frobenius distance to W _[∗],_ ferent amount of unlabeled data from 80
which is approximately linear in the generalization error, decreases in the order of 1/√M . As an exam- Million Tiny Images matches our theoret-ical prediction.

ple, Figure 1 shows that the proposed theoretical bound
matches the empirical self-training performance versus the number of unlabeled data for image classification; see details in Section 4.2.

**2. Analytical justification of iterative self-training over single shot alternative. We prove that**
the student models returned by the iterative self-training method converges linearly to a model close
to W _[∗], with the rate improvement in the order of 1/√M_ .

**3. Sample complexity analysis of labeled and unlabeled data for learning a proper model.**
We quantify the impact of labeled and unlabeled data on the generalization of the learned model.
In particular, we prove that the sample complexity of labeled data can be reduced compared with
supervised learning.

1.1 RELATED WORKS


**Semi-supervised learning. Besides self-training, many recent SemiSL algorithms exploit either**
consistency regularization or entropy minimization. Consistency regularization is based on the as

-----

sumption that the learned model will return same or similar output when the input is perturbed
(Laine & Aila, 2016; Bachman et al., 2014; Sajjadi et al., 2016; Tarvainen & Valpola, 2017; Reed
et al., 2015). (Grandvalet & Bengio, 2005) claims that the unlabeled data are more informative if the
pseudo labels of the unlabeled data have lower entropy. Therefore, a line of works (Grandvalet &
Bengio, 2005; Miyato et al., 2018) adds a regularization term that minimizes the entropy of the outputs of the unlabeled data. In addition, hybrid algorithms that unify both the above regularizations
have been developed like (Berthelot et al., 2019a;b; Sohn et al., 2020).

**Domain adaptation. Domain adaptation exploits abundant data in the source domain to learn a**
model for the target domain, where only limited training data are available (Liebelt & Schmid,
2010; Vazquez et al., 2013; Zhang et al., 2013; Long et al., 2015; Tzeng et al., 2014). Source and
target domain are related but different. Unsupervised domain adaptation (Ganin & Lempitsky, 2015;
Ganin et al., 2016; Gong et al., 2013; Bousmalis et al., 2016), where training data in target domain
are unlabeled, is similar to SemiSL, and self-training methods have been used for analysis (Zou
et al., 2018; Tang et al., 2012; French et al., 2018). However, self-training and unsupervised domain
adaptation are fundamentally different. The former learns a model for the domain where there is
limited labeled data, with the help of a large number of unlabeled data from a different domain. The
latter learns a model for the domain where the training data are unlabeled, with the help of sufficient
_labeled data from a different domain._

**Generalization analysis of supervised learning. In theory, the testing error is upper bounded by the**
training error plus the generalization gap between training and testing. These two quantities are often
analyzed separately and cannot be proved to be small simultaneously for deep neural networks. For
example, neural tangent kernel (NTK) method (Jacot et al., 2018; Du et al., 2018; Lee et al., 2018)
shows the training error can be zero, and the Rademacher complexity in (Bartlett & Mendelson,
2002) bounds the generalization gap (Arora et al., 2019a). For one-hidden-layer neural networks
(Safran & Shamir, 2018), the testing error can be proved to be zero under mild conditions. One
common assumption is that the input data belongs to the Gaussian distribution (Zhong et al., 2017;
Ge et al., 2018; Kalai et al., 2008; Bakshi et al., 2019; Zhang et al., 2016; Brutzkus & Globerson,
2017; Li & Yuan, 2017; Soltanolkotabi et al., 2018). Another line of approaches (Brutzkus et al.,
2018; Li & Liang, 2018; Wang et al., 2019) consider linearly separable data.

The rest of this paper is organized as follows. Section 2 introduces the problem formulation and
self-training algorithm. Major results are summarized in Section 3, and empirical evaluations are
presented in Section 4. Section 5 concludes the whole paper. All the proofs are in the Appendix.

2 FORMALIZING SELF-TRAINING: NOTATION, FORMULATION, AND
ALGORITHM

**Problem formulation.** Given N labeled data sampled from distribution Pl, denoted by D =
_{xn, yn}n[N]=1[, and][ M][ unlabeled data drawn from distribution][ P][u][, denoted by][ e]D = {xm}m[M]=1[. The]_

aim is to find a neural network model g(W ), where W denotes the trainable weights, that minimizes
the testing error on data sampled from Pl.

e

**Table 1: Iterative Self-Training**

(S1) Initialize iteration ℓ = 0 and obtain a model W [(][ℓ][)] as the teacher using labeled data D
only;
(S2) Use the teacher model to obtain pseudo labels _ym of unlabeled data in_ _D;_
(S3) Train the neural network by minimizing (1) via T -step mini-batch gradient descent
method using disjoint subsets _t_ _t=0_ [and][ {][ e]t _t=0 e_ [of][ e]. Let W [(][ℓ][+1)] denote the obtained[e]
_{D_ _}[T][ −][1]_ _D_ _}[T][ −][1]_ _D_
student model;
(S4) Use W [(][ℓ][+1)] as the current teacher model. Let ℓ _←_ _ℓ_ + 1 and go back to step (S2);


**Iterative self-training. In each iteration, given the current teacher predictor g(W** [(][ℓ][)]), the pseudolabels for the unlabeled data in _D are computed as ˜ym = g(W_ [(][ℓ][)]; **_xm). The method then minimizes_**
the weighted empirical risk _f[ˆ]D,D[(][W][ )][ of both labeled and unlabeled data through stochastic gradient]_

[e] e
e


-----

descent, where

_N_ _M_

_λ_ 2 _λ_ 2
_fˆD,D[(][W][ ) =]_ 2N _n=1_ _yn −_ _g(W ; xn)_ + 2M _m=1_ _ym −_ _g(W ;_ **_xm)_** _,_ (1)
e X    e X   

and λ + _λ = 1. The learned student model g(W_ [(][ℓ][+1)]) is used as the teacher model in the next iter-e e
ation. The initial model g(W [(0)]) is learned from labeled data. The formal algorithm is summarized
as in Table 1.

[e]

**Model and assumptions. This paper considers regression[1], where g is a one-hidden-layer fully**
connected neural network equipped with K neurons. Namely, given the input x ∈ R[d] and weights
**_W = [w1, w2, · · ·, wK] ∈_** R[d][×][K], we have

_K_

_g(W ; x) := [1]_ _φ(wj[T]_ **_[x][)][,]_** (2)

_K_

_j=1_

X

where φ is the ReLU activation function[2], and φ(z) = max{z, 0} for any input z ∈ R. Here, we fix
the top layer weights as 1 for simplicity, and the equivalence of such a simplification is discussed in
Appendix K.

Moreover, we assume an unknown ground-truth model with weights W _[∗]_ that maps all the features to
the corresponding labels drawn from Pl, i.e., y = g(W ; x), where (x, y) _Pl. The generalization_

_[∗]_ _∼_
function (GF) with respect to g(W ) is defined as

2 2
_I_ _g(W )_ = E(x,y)∼Pl _y −_ _g(W ; x)_ = E(x,y)∼Pl _g(W_ _[∗]; x) −_ _g(W ; x)_ _._ (3)

By definition  _I_ _g(W_ _[∗])_ is zero. Clearly,  **_W_** _[∗]is not unique because any column permutation of _ 
**_W_** _[∗], which corresponds to permuting neurons, represents the same function as W_ _[∗]_ and minimizes
  
GF in (3) too. To simplify the representation, we follow the convention and abuse the notation that
the distance from W to W _[∗], denoted by ∥W −_ **_W_** _[∗]∥F, means the smallest distance from W to_
any permutation of W _[∗]. Additionally, some important notations are summarized in Table 2._

We assume the inputs of both the labeled and unlabeled data belong to the zero mean Gaussian
distribution, i.e., x (0, δ[2]Id), and **_x_** (0, _δ[˜][2]Id). The Gaussian assumption is motivated_
_∼N_ _∼N_
by the data whitening (LeCun et al., 2012) and batch normalization techniques (Ioffe & Szegedy,
2015) that are commonly used in practice to improve learning performance. Moreover, training onee
hidden-layer neural network with multiple neurons is NP-Complete (Blum & Rivest, 1992) without
any assumption.

**The focus of this paper. This paper will analyze three aspects about self-training: (1) the gener-**
alization performance of W [(][L][)], the returned model by self-training after L iterations, measured by
_∥W_ [(][L][)] _−_ **_W_** _[∗]∥F_ [3]; (2) the influence of parameter λ in (1) on the training performance; and (3) the
impact of unlabeled data on the training and generalization performance.

Table 2: Some Important Notations

|D = {x n, y n}N n=1|Labeled dataset with N number of samples;|
|---|---|
|De = {x em}M m=1|Unlabeled dataset with M number of samples;|
|d|Dimension of the input x orx; e|
|K|Number of neurons in the hidden layer;|
|κ|Conditional number (the ratio of the largest and smallest singular values) of W∗;|
|W (ℓ)|Model returned by self-training after ℓiterations; W (0) is the initial model;|
|W∗|Weights of the ground truth model;|
|[λˆ] W|W [λˆ] = λˆW ∗+ (1 −λˆ)W (0);|



1The results can be extended to binary classification with a cross-entropy loss function. Please see
Appendix-I.

2Because ReLU is non-linear and non-smooth, (1) is non-convex and non-smooth, which poses analytical
challenges. The results can be easily extended to smooth functions with bounded gradients, e.g., Sigmoid.

3We use this metric because I _g(W )_ is shown to be linear in ∥W [(][L][)] _−_ **_W_** _[∗]∥F numerically when W_ [(][L][)]

is close to W _[∗], see Figure 4._

  


-----

3 THEORETICAL RESULTS

**Beyond supervised learning:** **Challenge of self-training.** The existing theoretical works
such as (Zhong et al., 2017; Zhang et al., 2020a;b;c) verify that for one-hidden-layer neural networks, if only labeled data are available, and x are drawn from the standard Gaussian distribution, then supervised learning by minimizing (1) with λ = 1 can return a
model with ground-truth weights W _[∗]_ (up to column permutation), as long as the number of labeled data N is at least N _[∗], which depends on κ, K and d._ In contrast, this
paper focuses on the low labeled-data regime when N is less than N _[∗]._ Specifically,


_N_ _[∗]/4 < N ≤_ _N_ _[∗]._ (4)

Intuitively, if N < N _[∗], the landscape of the empir-_
ical risk of the labeled data becomes highly nonconvex, even in a neighborhood of W _[∗], thus, the_
existing analyses for supervised learning do not
hold in this region. With additional unlabeled data,
the landscape of the weighted empirical risk becomes smoother near W _[∗]. Moreover, as M in-_
creases, and starting from a nearby initialization,
the returned model W [(][L][)] by iterative self-training
can converge to a local minimum that is closer to
**_W_** _[∗]_ (see illustration in Figure 2).


Objective function


without unlabeled data

Objective function

with unlabeled data

Local minima

Generalization

function

𝑾𝑾

𝑾𝑾[(0)]


𝑾𝑾[∗]


Figure 2: Adding unlabeled data in the empirical risk function drives its local minimum
closer to W _[∗], which minimizes the generaliza-_
tion function.


Compared with supervised learning, the formal analyses of self-training need to handle new technical challenges from two aspects. First, the existing analyses of supervised learning exploit the fact
that the GF and the empirical risk have the same minimizer, i.e., W _[∗]. This property does not hold_
for self-training as W _[∗]_ no longer minimizes the weighted empirical risk in (1). Second, the iterative
manner of self-training complicates the analyses. Specifically, the empirical risk in each iteration is
different and depends on the model trained in the previous iteration through the pseudo labels.

In what follows, we provide theoretical insights and the formal theorems. Some important quantities
_λˆ and µ are defined below_

_λδ[2]_ _λδ[2]_ + _λδ[˜][2]_
_λˆ :=_ and _µ = µ(δ,_ _δ[˜]) :=_ _,_ (5)

_λδ[2]_ + _λδ[˜][2][,]_ s _λρ(δ) +_ _λρ(δ[˜])_

[e]

where ρ is a positive function defined in (73). _λ[ˆ] is an increasing function of λ. Also, from Lemma_
11 (in Appendix), ρ(δ) is in the order of[e] _δ[2]_ when δ ≤ 1 for ReLU activation functions. Thus,[e] _µ is a_
fixed constant, denoted by µ[∗], for all δ, _δ[˜] ≤_ 1. When δ and _δ[˜] are large, µ increases as they increase._

The formal definition of N _[∗]_ in (4) is c(κ)µ[∗][2]K [3]d log q, where c(κ) is some polynomial function of
_κ and can be viewed as constant._

3.1 INFORMAL KEY THEORETICAL FINDINGS

To the best of our knowledge, Theorems 1 and 𝜟𝜟𝟎𝟎 𝓔𝓔𝟏𝟏 = 1 + 𝒪𝒪 𝑀𝑀 ȉ [ℰ]𝐾𝐾[0]
2 provide the first theoretical characterization of 𝑾𝑾[(2)] **. . .**
iterative self-training on nonlinear neural net- 𝑾𝑾[(1)]
works. Before formally presenting them, we
summarize the highlights as follows.


**1. Linear convergence of the learned models.**
The learned models converge linearly to a model
close to W _[∗]. Thus, the iterative approach re-_
turns a model with better generalization than that
by the single-shot method. Moreover, the convergence rate is a constant term plus a term in
the order of 1/√M (see ∆1 in Figure 3), indi
cating a faster convergence with more unlabeled
data.


1

𝜟𝜟𝟎𝟎 𝓔𝓔𝟏𝟏 = 1 + 𝒪𝒪 𝑀𝑀 ȉ [ℰ]𝐾𝐾[0]

𝑾𝑾[(2)] **. . .**

𝑾𝑾[(𝐿𝐿)]

𝑾𝑾[(1)]

𝑾𝑾[(0)] 𝑾𝑾[[෡]𝜆𝜆] 𝑾𝑾[∗]

𝜟𝜟𝟏𝟏 = 1 + 𝒪𝒪 𝑀𝑀1 ȉ [Δ]𝐾𝐾[0]
𝓔𝓔𝟎𝟎 = 1 −𝜆𝜆ȉ 𝑾𝑾[̂] [∗] −𝑾𝑾[(0)]

Figure 3: Illustration of the (1) ground truth W _[∗],_
**_W(2) iterations[(][L][)], and (4) { WW[[ˆ][(]λ[ℓ]][)] = ˆ}ℓ[L]=0λW[, (3) convergent point][∗]_** + (1 − _λ[ˆ])W_ [(0)].


-----

**2. Returning a model with guaranteed generalization in the low labeled-data regime. Even**
when the number of labeled data is much less than the required sample complexity to obtain W _[∗]_
in supervised learning, we prove that with the help of unlabeled data, the iterative self-training can
return a model in the neighborhood of W [[ˆ]λ], where W [λ[ˆ]] is in the line segment of W (0) (λˆ = 0)
and ground truth W _[∗]_ (λ[ˆ] = 1). Moreover, _λ[ˆ] is upper bounded by_ _N/N_ _[∗]. Thus W_ [(][L][)] moves

closer to W _[∗]_ as N increases (E0 in Figure 3), indicating a better generalization performance withp
more labeled data.

**3. Guaranteed generalization improvement by unlabeled data. The distance between W** [(][L][)]

_λ]_
andM, W W[(][[ˆ][L][)] (moves closer toE1 in Figure 3) scales in the order of W [[ˆ]λ] and thus W ∗, indicating an improved generalization performance 1/√M . With a larger number of unlabeled data

(Theorem 1). When N is close to N _[∗]_ but still smaller as defined in (12), both W [(][L][)] and W [[ˆ]λ]
converge to W _[∗], and thus the learned model achieves zero generalization error (Theorem 2)._

3.2 FORMAL THEORY IN LOW LABELED-DATA REGIME

_Takeaways of Theorem 1: Theorem 1 characterizes the convergence rate of the proposed algorithm_
and the accuracy of the learned model W [(][L][)] in a low labeled-data regime. Specifically, the iterates
converge linearly, and the learned model is close to W [[ˆ]λ] and guaranteed to outperform the initial
model W [(0)].
**Theorem 1. Suppose the initialization W** [(0)] _and the number of labeled data satisfy_

**_W_** _F_ 1
**_W_** [(0)] **_W_** _F_ _p[−][1]_ _∥_ _[∗]∥_ _with_ _p_ _,_ (6)
_∥_ _−_ _[∗]∥_ _≤_ _·_ _c(κ)µ[2]K_ [3][/][2] _∈_ 2 _[,][ 1]_

2   

1
_and_ max _K [, p][ −]_ [2]µ[p]√[ −]K[1] _· N_ _[∗]_ _≤_ _N ≤_ _N_ _[∗]._ (7)
n o

_If the value of_ _λ[ˆ] in (5) and unlabeled data amount M satisfy_

1 _N_
max _K [, p][ −]_ [2]µ[p]√[ −]K[1] _≤_ _λ[ˆ] ≤_ min _N_ _[∗]_ _[, p][ + 2]µ[p]√[ −]K[1]_ _,_ (8)

_and_ _M ≥n_ (2p − 1)[−][2]c(κo)µ[2][ ]1 − _λ[ˆ]_ 2Kn[r]3d log q. o (9)
_Then, when the number T of SGD iterations is large enough in each loop ℓ, with probability at least_

1 − _q[−][d], the iterates {W_ [(][ℓ][)]}ℓ[L]=0 _[converge to][ W][ [ˆ]λ] as_

_L_

_∥W_ [(][L][)] _−_ **_W_** [[ˆ]λ]∥F ≤ 1 + Θ _µ(1√−Mλˆ)_ _·_ _λ[ˆ]_ _· ∥W_ [(0)] _−_ **_W_** [[ˆ]λ]∥2 + 1 + Θ _µ(1√−Mλˆ)_ _· ∥W_ _[∗]_ _−_ **_W_** [[ˆ]λ]∥F,
   []     [] (10)

_where W_ [[ˆ]λ] = ˆλW _[∗]_ + (1 − _λ[ˆ])W_ [(0)]. Typically, when the iteration number L is sufficient large, we
_have_

_µ(1_ _λ)_
_∥W_ [(][L][)] _−_ **_W_** _[∗]∥F ≤_ 1 + Θ _√ −M[ˆ]_ _· 2(1 −_ _λ[ˆ]) · ∥W_ _[∗]_ _−_ **_W_** [(0)]∥F . (11)
   []

The accuracy of the learned model W [(][L][)] with respect to W _[∗]_ is characterized as (10), and the
learning model is better than initial model as in (11) if the following conditions hold. First, the
weights λ in (1) are properly chosen as in (8). Second, the number of unlabeled data is sufficiently
large as in (9).

**Selection of λ in self-training algorithms. When** _λ[ˆ] increases, the required number of unlabeled_
data is reduced from (9), and the convergence point W [(][L][)] becomes closer to W _[∗]_ from (11), which
indicates a smaller generalization error. Thus, a large _λ[ˆ] within its feasible range (8) is desirable._
When the initial model W [(0)] is closer to W _[∗]_ (corresponding to a larger p), and the number of
labeled data N increases, the upper bound in (8) increases, and thus, one can select a larger _λ[ˆ]._

**The initial model W** [(0)]. The tensor initialization from (Zhong et al., 2017) can return a W [(0)] that
satisfies (6) when the number of labeled data is N = p[2]N _[∗]_ (see Lemma 3 in Appendix). Combining
with the requirement in (7), Theorem 1 applies to the case that N is at least N _[∗]/4._


-----

3.3 FORMAL THEORY OF ACHIEVING ZERO GENERALIZATION ERROR

_Takeaways of Theorem 2: Theorem 2 indicates the model returned by the proposed algorithm con-_
verges linearly to the ground truth W _[∗]. Thus the distance between the learned model and the ground_
truth can be arbitrarily small with the ability to achieve zero generalization error. The required sample complexity is reduced by a constant factor compared with supervised learning.
**Theorem 2. Consider the number of unlabeled data satisfies**

2

1 − 1/(µ√K) _· N ∗_ _≤_ _N ≤_ _N ∗,_ (12)

_we choose_ _λ[ˆ] such that_   
1 − 1/(µ√K) ≤ _λ[ˆ] ≤_ _N/N_ _[∗]._ (13)

_Suppose the initial model W_ [(0)] _and the number of unlabeled datap_ _M satisfy_


**_W_** _F_
**_W_** [(0)] **_W_** _F_ _∥_ _[∗]∥_ _and_ _M_ _c(κ)µ[2](1_ _λ)[2]K_ [3]d log q, (14)
_∥_ _−_ _[∗]∥_ _≤_ _c(κ)µ[2]K_ [3][/][2] _≥_ _−_ [ˆ]

_the iterates {W_ [(][ℓ][)]}ℓ[L]=0 _[converge to the ground truth][ W][ ∗]_ _[as follows,]_

_∥W_ [(][L][)] _−_ **_W_** _[∗]∥F ≤_ 1 + _[c]√[(][κ]N[)ˆ]λ_ + _[c][(][κ][)(1]√M[ −]_ _λ[ˆ])_ _· µ√K(1 −_ _λ[ˆ])_ _L_ _· ∥W_ [(0)] _−_ **_W_** _[∗]∥F ._ (15)
h   i

The models W [(][ℓ][)]’s converge linearly to the ground truth W _[∗]_ as (15) when the number of labeled
data satisfies (12). In contrast, supervised learning requires at least N _[∗]_ labeled samples to estimate
**_W_** _[∗]_ accurately without unlabeled data, which suggests self-training at least saves a constant fraction
of labeled data.


3.4 THE MAIN PROOF IDEA

Our proof builds upon and extends one recent line of works on supervised learning such as (Zhong
et al., 2017; Zhang et al., 2020b;c; 2021). The standard framework of these works is first to show
that the generalization function I(g(W )) in (3) is locally convex near W _[∗], which is its global_
minimizer. Then, when M = 0 and N is sufficiently large, the empirical risk function using labeled
data only can approximate I(g(W )) well in the neighborhood of W _[∗]. Thus, if initialized in this_
local convex region, the iterations, returned by applying gradient descent approach on the empirical
risk function, converge to W _[∗]_ linearly.

The technical challenge here is that in self-training, when unlabeled data are paired with pseudo
labels, W _[∗]_ is no longer a global minimizer of the empirical risk _f[ˆ]_ _,_ [in (1), and][ ˆ]f _,_ [does not]
_D_ _D_ _D_ _D_
approach I(g(W )) even when M and N increase to infinity. Our new idea is to design a population
e e
risk function f (W ; λ[ˆ]) in (17) (see appendix), which is a lower bound of _f[ˆ]_ _,_ [when][ M][ and][ N][ are]
_D_ _D_

infinity. f (W ; λ[ˆ]) is locally convex around its minimizer W [[ˆ]λ], and W [λ[ˆ]] approaches e **_W ∗_** as ˆλ
increases. Then we show the iterates generated by _f[ˆ]_ _,_ [stay close to][ f] [(][W][ ; ˆ]λ), and the returned
_D_ _D_

model W [(][L][)] is close to W [[ˆ]λ]. New technical tools are developed to bound the distance between the

e

functions _f[ˆ]_ _,_ [and][ f] [(][W][ ; ˆ]λ).
_D_ eD

4 EMPIRICAL RESULTS

4.1 SYNTHETIC DATA EXPERIMENTS


We generate a ground-truth neural network with the width K = 10. Each entry of W _[∗]_ is uniformly
selected from [−2.5, 2.5]. The input of labeled data xn are generated from Gaussian distribution
_N_ (0, Id) independently, and the corresponding label yn is generated through (2) using W _[∗]. The_
unlabeled data **_xm are generated from N_** (0, _δ[2]Id) independently with_ _δ = 1 except in Figure 7._
_d is set as 50 except in Figure 9. The value of λ is selected as_ _N/(2Kd) except in Figure 8._

We consider one-hidden-layer except in Figure 4. The initial teacher model e [e] [e] **_W_** [(0)] in self-training

p

is randomly selected from {W |∥W − **_W_** _[∗]∥F /∥W_ _[∗]∥F ≤_ 0.5} to reduce the computation. In


-----

each iteration, the maximum number of SGD steps T is 10. Self-training terminates if ∥W [(][ℓ][+1)] _−_
**_Wcurves are averaged over[(][ℓ][)]∥F /∥W_** [(][ℓ][)]∥F ≤ 10 1000[−][4] or reaching independent trials, and the regions in lower transparency indicate 1000 iterations. In Figures 5 to 8, all the points on the
the corresponding one-standard-deviation error bars. Our empirical observations are summarized
below.

**(a) GF (testing performance) proportional to ∥W −** **_W_** _[∗]∥F . Figure 4 illustrates the GF in (3)_
against the distance to the ground truth W _[∗]. To visualize results for different networks together,_
GF is normalized in [0, 1], divided by its largest value for each network architecture. All the results
are averaged over 100 independent choice of W . One can see that for one-hidden-layer neural
networks, in a large region near W _[∗], GF is almost linear in ∥W −_ **_W_** _[∗]∥F . When the number of_
hidden layers increases, this region decreases, but the linear dependence still holds locally. This is
an empirical justification of using ∥W − **_W_** _[∗]∥F to evaluate the GF and, thus, the testing error in_
Theorems 1 and 2.

**(b) ∥W** [(][L][)] _−_ **_W_** _[∗]∥F as a linear function of 1/√M_ **. Figure 5 shows the relative error ∥W** [(][L][)] _−_

**_W_** _[∗]∥F /∥W_ _[∗]∥F when the number of unlabeled data and labeled data changes. One can see that the_
relative error decreases when either M or N increases. Additionally, the dash-dotted lines represent
the best fitting of the linear functions of 1/√M using the least square method. Therefore, the relative

error is indeed a linear function of 1/√M, as predicted by our results in (11) and (15).


1

0.8

0.6

0.4 1-hidden-layer

5-hidden-layer

0.2 10-hidden-layer

50-hidden-layer

0

0 0.1 0.2 0.3 0.4 0.5


N = 250

0.99955 N = 300

N = 350

0.9995

0.99945

0.9994

Convergence rate0.99935

0.9993

0.0165 0.017 0.0175 0.018


4.3

4

3.5

Relative error (%)

3

200 400 600 800 1000

Number of unlabeled data (M)


Figure 4: The generalization
function against the distance to
the ground truth neural network


Figure 6: The convergence rate
with different M when N _<_
_N_ _[∗]._


Figure 5: The relative error
against the number of unlabeled
data.


**(c) Convergence rate as a linear function of 1/√M** **. Figure 6 illustrates the convergence rate**

when M and N change. We can see that the convergence rate is a linear function of 1/√M, as

predicted by our results (11) and (15). When M increases, the convergence rate is improved, and
the method converges faster.

**(d) Increase of** _δ slows down convergence. Figure 7 shows that the convergence rate becomes_
worse when the variance of the unlabeled data _δ increases from 1. When_ _δ is less than 1, the_
convergence rate almost remains the same, which is consistent with our characterization in (10) that[e]
the convergence rate is linear in µ. From the discussion after (5),[e] _µ increases as[e]_ _δ increases from 1_
and stays constant when _δ is less than 1._

[e]

**(e) ∥W** [(][L][)]−W _[∗]∥F /∥W[e][∗]∥F is improved as a linear function of_ _λ[ˆ]. Figure 8 shows that the relative_
errors of W [(][L][)] with respect to W _[∗]_ decrease almost linearly when _λ[ˆ] increases, which is consistent_
with the theoretical result in (11). Moreover, when λ exceeds a certain threshold positively correlated
with N, the relative error increases rather than decreases. That is consistent with the analysis in (8)
that _λ[ˆ] has an upper limit, and such a limit increases as N increases._

**(f) Unlabeled data reduce the sample complexity to learn W** _[∗]. Figure 9 depicts the phase tran-_
sition of returning W [(][L][)]. For every pair of d and N, we construct 100 independent trials, and each
the successful trials, while the block in black indicates all failures. Whentrial is said to be successful if ∥W [(][L][)] _−_ **_W_** _[∗]∥F /∥W_ _[∗]∥F ≤_ 10[−][2]. The white blocks correspond to d increases, the required
number of labeled data to learn W _[∗]_ is linear in d. Thus, the sample complexity bound in (12) is
order-wise optimal for d. Moreover, the phase transition line when M = 1000 is below the one
when M = 0. Therefore, with unlabeled data, the required sample complexity of N is reduced.


-----

6.9 N=200 680 680

6.5 N=240 620 620

N=280 560 560

6.1 500 500

440 440

5.7 380320 380320

Relative error (%) 260 260

5.3 200 200

0.1 0.2 0.3 0.4 0.5 20 26 32 38 44 50 20 26 32 38 44 50


1

0.995

Convergence rate 0.99

1 2 3 4 5


Figure 8: _∥W_ _∥[(][L]W[)]−[∗]W∥F_ _[∗]∥F_

when _λ[ˆ] and N change._


Figure 7: Convergence rate
with different _δ[ˆ]._


Figure 9: Empirical phase transition of
the curves with (a) M = 0 and (b) M =
1000.


4.2 IMAGE CLASSIFICATION ON AUGMENTED CIFAR-10 DATASET

We evaluate self-training on the augmented CIFAR-10 dataset, which has 50K labeled data. The
unlabeled data are mined from 80 Million Tiny Images following the setup in (Carmon et al., 2019)[4],
and additional 50K images are selected for each class, which is a total of 500K images, to form the
unlabeled data. The self-training method is the same implementation as that in (Carmon et al., 2019).
_λ and_ _λ is selected as N/(M + N_ ) and M/(N + M ), respectively, and the algorithm stops after
200 epochs. In Figure 10, the dash lines stand for the best fitting of the linear functions of 1/√M

via the least square method. One can see that the test accuracy is improved by up to 7% using

[e]

unlabeled data, and the empirical evaluations match the theoretical predictions. Figure 11 shows the
convergence rate calculated based on the first 50 epochs, and the convergence rate is almost a linear
function of 1/√M, as predicted by (10).


0.962

0.96

0.958

0.956

0.954

0.952

|Col1|Col2|Col3|Col4|Col5|Col6|
|---|---|---|---|---|---|
|||||||
||||||N=15K|


N=15K
N=30K
N=50K


5 6 7 8 9 10

10[-3]

Figure 11: The convergence rate against the
number of unlabeled data


90

85

Test accuracy (%)

80

0 100K 200K 300K 400K 500K

Number of unlabeled data (M)


Figure 10: The test accuracy against the
number of unlabeled data


5 CONCLUSION

This paper provides new theoretical insights into understanding the influence of unlabeled data in
the iterative self-training algorithm. We show that the improved generalization error and convergence rate is a linear function of 1/√M, where M is the number of unlabeled data. Moreover,

compared with supervised learning, using unlabeled data reduces the required sample complexity of
labeled data for achieving zero generalization error. Future directions include generalizing the analysis to multi-layer neural networks and other semi-supervised learning problems such as domain
adaptation.


ACKNOWLEDGEMENT

This work was supported by AFOSR FA9550-20-1-0122, ARO W911NF-21-1-0255, NSF 1932196
and the Rensselaer-IBM AI Research Collaboration (http://airc.rpi.edu), part of the IBM AI Horizons Network (http://ibm.biz/AIHorizons).


4The codes are downloaded from https://github.com/yaircarmon/semisup-adv


-----

REFERENCES

Zeyuan Allen-Zhu, Yuanzhi Li, and Yingyu Liang. Learning and generalization in overparameterized neural networks, going beyond two layers. In Advances in neural information processing
_systems, pp. 6158–6169, 2019._

Sanjeev Arora, Simon Du, Wei Hu, Zhiyuan Li, and Ruosong Wang. Fine-grained analysis of optimization and generalization for overparameterized two-layer neural networks. In International
_Conference on Machine Learning, pp. 322–332. PMLR, 2019a._

Sanjeev Arora, Simon S Du, Wei Hu, Zhiyuan Li, and Ruosong Wang. Fine-grained analysis of
optimization and generalization for overparameterized two-layer neural networks. In 36th In_ternational Conference on Machine Learning, ICML 2019, pp. 477–502. International Machine_
Learning Society (IMLS), 2019b.

Philip Bachman, Ouais Alsharif, and Doina Precup. Learning with pseudo-ensembles. Advances in
_neural information processing systems, 2014._

Ainesh Bakshi, Rajesh Jayaram, and David P Woodruff. Learning two layer rectified neural networks
in polynomial time. In Conference on Learning Theory, pp. 195–268. PMLR, 2019.

Maria-Florina Balcan and Avrim Blum. A discriminative model for semi-supervised learning. Jour_nal of the ACM (JACM), 57(3):1–46, 2010._

Peter L Bartlett and Shahar Mendelson. Rademacher and gaussian complexities: Risk bounds and
structural results. Journal of Machine Learning Research, 3(Nov):463–482, 2002.

David Berthelot, Nicholas Carlini, Ekin D Cubuk, Alex Kurakin, Kihyuk Sohn, Han Zhang, and
Colin Raffel. Remixmatch: Semi-supervised learning with distribution matching and augmentation anchoring. In International Conference on Learning Representations, 2019a.

David Berthelot, Nicholas Carlini, Ian Goodfellow, Nicolas Papernot, Avital Oliver, and Colin
Raffel. Mixmatch: A holistic approach to semi-supervised learning. _arXiv preprint_
_arXiv:1905.02249, 2019b._

Rajendra Bhatia. Matrix analysis, volume 169. Springer Science & Business Media, 2013.

Avrim L Blum and Ronald L Rivest. Training a 3-node neural network is np-complete. Neural
_Networks, 5(1):117–127, 1992._

Konstantinos Bousmalis, George Trigeorgis, Nathan Silberman, Dilip Krishnan, and Dumitru Erhan.
Domain separation networks. In Proceedings of the 30th International Conference on Neural
_Information Processing Systems, pp. 343–351, 2016._

Alon Brutzkus and Amir Globerson. Globally optimal gradient descent for a convnet with gaussian
inputs. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pp.
605–614. JMLR. org, 2017.

Alon Brutzkus, Amir Globerson, Eran Malach, and Shai Shalev-Shwartz. Sgd learns overparameterized networks that provably generalize on linearly separable data. In International
_Conference on Learning Representations, 2018._

Yair Carmon, Aditi Raghunathan, Ludwig Schmidt, John C Duchi, and Percy S Liang. Unlabeled
data improves adversarial robustness. Advances in Neural Information Processing Systems, 32:
11192–11203, 2019.

Ting Chen, Simon Kornblith, Kevin Swersky, Mohammad Norouzi, and Geoffrey E Hinton. Big
self-supervised models are strong semi-supervised learners. _Advances in Neural Information_
_Processing Systems, 33:22243–22255, 2020a._

Yining Chen, Colin Wei, Ananya Kumar, and Tengyu Ma. Self-training avoids using spurious
features under domain shift. Advances in Neural Information Processing Systems, 33, 2020b.


-----

Simon S Du, Xiyu Zhai, Barnabas Poczos, and Aarti Singh. Gradient descent provably optimizes
over-parameterized neural networks. In International Conference on Learning Representations,
2018.

Geoffrey French, Michal Mackiewicz, and Mark Fisher. Self-ensembling for visual domain adaptation. In International Conference on Learning Representations, number 6, 2018.

Haoyu Fu, Yuejie Chi, and Yingbin Liang. Guaranteed recovery of one-hidden-layer neural networks
via cross entropy. IEEE Transactions on Signal Processing, 68:3225–3235, 2020.

Yaroslav Ganin and Victor Lempitsky. Unsupervised domain adaptation by backpropagation. In
_International conference on machine learning, pp. 1180–1189. PMLR, 2015._

Yaroslav Ganin, Evgeniya Ustinova, Hana Ajakan, Pascal Germain, Hugo Larochelle, François
Laviolette, Mario Marchand, and Victor Lempitsky. Domain-adversarial training of neural networks. The journal of machine learning research, 17(1):2096–2030, 2016.

Rong Ge, Jason D. Lee, and Tengyu Ma. Learning one-hidden-layer neural networks with land[scape design. In International Conference on Learning Representations, 2018. URL https:](https://openreview.net/forum?id=BkwHObbRZ)
[//openreview.net/forum?id=BkwHObbRZ.](https://openreview.net/forum?id=BkwHObbRZ)

Boqing Gong, Kristen Grauman, and Fei Sha. Connecting the dots with landmarks: Discriminatively learning domain-invariant features for unsupervised domain adaptation. In International
_Conference on Machine Learning, pp. 222–230. PMLR, 2013._

Yves Grandvalet and Yoshua Bengio. Semi-supervised learning by entropy minimization. In Con_ference d’apprentissage CAp, pp. 281, 2005._

Jiangfan Han, Ping Luo, and Xiaogang Wang. Deep self-learning from noisy labels. In Proceedings
_of the IEEE/CVF International Conference on Computer Vision, pp. 5138–5147, 2019._

Junxian He, Jiatao Gu, Jiajun Shen, and Marc’Aurelio Ranzato. Revisiting self-training for neural
sequence generation. In International Conference on Learning Representations, 2019.

Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. volume 37 of Proceedings of Machine Learning Research, pp.
448–456, Lille, France, 07–09 Jul 2015. PMLR.

Arthur Jacot, Franck Gabriel, and Clément Hongler. Neural tangent kernel: Convergence and generalization in neural networks. In Proceedings of the 32nd International Conference on Neural
_Information Processing Systems, 2018._

Jacob Kahn, Ann Lee, and Awni Hannun. Self-training for end-to-end speech recognition. In
_ICASSP 2020-2020 IEEE International Conference on Acoustics, Speech and Signal Processing_
_(ICASSP), pp. 7084–7088. IEEE, 2020._

Adam Tauman Kalai, Adam R Klivans, Yishay Mansour, and Rocco A Servedio. Agnostically
learning halfspaces. SIAM Journal on Computing, 37(6):1777–1805, 2008.

Volodymyr Kuleshov, Arun Chaganty, and Percy Liang. Tensor factorization via matrix factorization. In Artificial Intelligence and Statistics, pp. 507–516, 2015.

Samuli Laine and Timo Aila. Temporal ensembling for semi-supervised learning. arXiv preprint
_arXiv:1610.02242, 2016._

Yann A LeCun, Léon Bottou, Genevieve B Orr, and Klaus-Robert Müller. Efficient backprop. In
_Neural networks: Tricks of the trade, pp. 9–48. Springer, 2012._

Dong-Hyun Lee et al. Pseudo-label: The simple and efficient semi-supervised learning method for
deep neural networks. In Workshop on challenges in representation learning, ICML, volume 3,
2013.

Jaehoon Lee, Yasaman Bahri, Roman Novak, Samuel S Schoenholz, Jeffrey Pennington, and Jascha
Sohl-Dickstein. Deep neural networks as gaussian processes. In International Conference on
_Learning Representations, 2018._


-----

Kibok Lee, Kimin Lee, Jinwoo Shin, and Honglak Lee. Overcoming catastrophic forgetting with unlabeled data in the wild. In Proceedings of the IEEE/CVF International Conference on Computer
_Vision, pp. 312–321, 2019._

Yuanzhi Li and Yingyu Liang. Learning overparameterized neural networks via stochastic gradient
descent on structured data. In Advances in Neural Information Processing Systems, pp. 8157–
8166, 2018.

Yuanzhi Li and Yang Yuan. Convergence analysis of two-layer neural networks with ReLU activation. In Advances in Neural Information Processing Systems, pp. 597–607. 2017.

Joerg Liebelt and Cordelia Schmid. Multi-view object class detection with a 3d geometric model.
In 2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition, pp.
1688–1695. IEEE, 2010.

Mingsheng Long, Yue Cao, Jianmin Wang, and Michael Jordan. Learning transferable features with
deep adaptation networks. In International conference on machine learning, pp. 97–105. PMLR,
2015.

Takeru Miyato, Shin-ichi Maeda, Masanori Koyama, and Shin Ishii. Virtual adversarial training: a
regularization method for supervised and semi-supervised learning. IEEE transactions on pattern
_analysis and machine intelligence, 41(8):1979–1993, 2018._

Luca Oneto, Davide Anguita, Alessandro Ghio, and Sandro Ridella. The impact of unlabeled patterns in rademacher complexity theory for kernel classifiers. Advances in neural information
_processing systems, 24:585–593, 2011._

Samet Oymak and Talha Cihad Gulcu. Statistical and algorithmic insights for semi-supervised
learning with self-training. arXiv preprint arXiv:2006.11006, 2020.

Samet Oymak and Mahdi Soltanolkotabi. End-to-end learning of a convolutional neural network via
deep tensor decomposition. arXiv preprint arXiv: 1805.06523, 2018.

Aditi Raghunathan, Sang Michael Xie, Fanny Yang, John Duchi, and Percy Liang. Understanding
and mitigating the tradeoff between robustness and accuracy. In International Conference on
_Machine Learning, pp. 7909–7919. PMLR, 2020._

Scott E Reed, Honglak Lee, Dragomir Anguelov, Christian Szegedy, Dumitru Erhan, and Andrew
Rabinovich. Training deep neural networks on noisy labels with bootstrapping. In ICLR (Work_shop), 2015._

Philippe Rigollet. Generalization error bounds in semi-supervised classification under the cluster
assumption. Journal of Machine Learning Research, 8(7), 2007.

Chuck Rosenberg, Martial Hebert, and Henry Schneiderman. Semi-supervised self-training of object
detection models. In Proceedings of the Seventh IEEE Workshops on Application of Computer
_Vision (WACV/MOTION’05)-Volume 1-Volume 01, pp. 29–36, 2005._

Itay Safran and Ohad Shamir. Spurious local minima are common in two-layer relu neural networks.
In International Conference on Machine Learning, pp. 4430–4438, 2018.

Mehdi Sajjadi, Mehran Javanmardi, and Tolga Tasdizen. Regularization with stochastic transformations and perturbations for deep semi-supervised learning. Advances in neural information
_processing systems, 29:1163–1171, 2016._

Henry Scudder. Probability of error of some adaptive pattern-recognition machines. IEEE Transac_tions on Information Theory, 11(3):363–371, 1965._

Aarti Singh, Robert Nowak, and Jerry Zhu. Unlabeled data: Now it helps, now it doesn’t. Advances
_in neural information processing systems, 21:1513–1520, 2008._

Kihyuk Sohn, David Berthelot, Nicholas Carlini, Zizhao Zhang, Han Zhang, Colin A Raffel,
Ekin Dogus Cubuk, Alexey Kurakin, and Chun-Liang Li. Fixmatch: Simplifying semi-supervised
learning with consistency and confidence. Advances in Neural Information Processing Systems,
33, 2020.


-----

Mahdi Soltanolkotabi, Adel Javanmard, and Jason D Lee. Theoretical insights into the optimization
landscape of over-parameterized shallow neural networks. IEEE Transactions on Information
_Theory, 65(2):742–769, 2018._

Jong-Chyi Su, Subhransu Maji, and Bharath Hariharan. When does self-supervision improve fewshot learning? In European Conference on Computer Vision, pp. 645–666. Springer, 2020.

Kevin Tang, Vignesh Ramanathan, Fei-Fei Li, and Daphne Koller. Shifting weights: Adapting
object detectors from image to video. In Advances in Neural Information Processing Systems, pp.
647–655, 2012.

Antti Tarvainen and Harri Valpola. Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results. In Proceedings of the 31st Interna_tional Conference on Neural Information Processing Systems, pp. 1195–1204, 2017._

Joel A Tropp. User-friendly tail bounds for sums of random matrices. Foundations of computational
_mathematics, 12(4):389–434, 2012._

Eric Tzeng, Judy Hoffman, Ning Zhang, Kate Saenko, and Trevor Darrell. Deep domain confusion:
Maximizing for domain invariance. arXiv preprint arXiv:1412.3474, 2014.

David Vazquez, Antonio M Lopez, Javier Marin, Daniel Ponsa, and David Geronimo. Virtual and
real world adaptation for pedestrian detection. IEEE transactions on pattern analysis and machine
_intelligence, 36(4):797–809, 2013._

Roman Vershynin. Introduction to the non-asymptotic analysis of random matrices. arXiv preprint
_arXiv:1011.3027, 2010._

Gang Wang, Georgios B Giannakis, and Jie Chen. Learning relu networks on linearly separable
data: Algorithm, optimality, and generalization. IEEE Transactions on Signal Processing, 67(9):
2357–2370, 2019.

Colin Wei, Kendrick Shen, Yining Chen, and Tengyu Ma. Theoretical analysis of self-training
with deep networks on unlabeled data. In International Conference on Learning Representations,
2020.

Qizhe Xie, Minh-Thang Luong, Eduard Hovy, and Quoc V Le. Self-training with noisy student
improves imagenet classification. In Proceedings of the IEEE/CVF Conference on Computer
_Vision and Pattern Recognition, pp. 10687–10698, 2020._

I Zeki Yalniz, Hervé Jégou, Kan Chen, Manohar Paluri, and Dhruv Mahajan. Billion-scale semisupervised learning for image classification. arXiv preprint arXiv:1905.00546, 2019.

David Yarowsky. Unsupervised word sense disambiguation rivaling supervised methods. In 33rd
_annual meeting of the association for computational linguistics, pp. 189–196, 1995._

Kun Zhang, Bernhard Schölkopf, Krikamol Muandet, and Zhikun Wang. Domain adaptation under
target and conditional shift. In International Conference on Machine Learning, pp. 819–827.
PMLR, 2013.

Shuai Zhang, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. Guaranteed convergence
of training convolutional neural networks via accelerated gradient descent. In 2020 54th An_[nual Conference on Information Sciences and Systems (CISS), 2020a. URL doi:10.1109/](doi: 10.1109/CISS48834.2020.1570627111)_
[CISS48834.2020.1570627111.](doi: 10.1109/CISS48834.2020.1570627111)

Shuai Zhang, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. Fast learning of graph neural
networks with guaranteed generalizability:one-hidden-layer case. In 2020 International Confer_ence on Machine Learning (ICML), 2020b._

Shuai Zhang, Meng Wang, Jinjun Xiong, Sijia Liu, and Pin-Yu Chen. Improved linear convergence
of training cnns with generalizability guarantees: A one-hidden-layer case. IEEE Transactions
_on Neural Networks and Learning Systems, 32(6):2622–2635, 2020c._


-----

Shuai Zhang, Meng Wang, Sijia Liu, Pin-Yu Chen, and Jinjun Xiong. Why lottery ticket wins? a theoretical perspective of sample complexity on pruned neural networks. In Thirty-fifth Conference
_on Neural Information Processing Systems (NeurIPS), 2021._

Xiao Zhang, Yaodong Yu, Lingxiao Wang, and Quanquan Gu. Learning one-hidden-layer relu
networks via gradient descent. In The 22nd International Conference on Artificial Intelligence
_and Statistics, pp. 1524–1534. PMLR, 2019._

Yuchen Zhang, Jason D. Lee, and Michael I. Jordan. L1-regularized neural networks are improperly
learnable in polynomial time. In Proceedings of The 33rd International Conference on Machine
_Learning, volume 48, pp. 993–1001, 2016._

Kai Zhong, Zhao Song, Prateek Jain, Peter L Bartlett, and Inderjit S Dhillon. Recovery guarantees for one-hidden-layer neural networks. In Proceedings of the 34th International Conference
_on Machine Learning-Volume 70, pp. 4140–4149. JMLR. org, https://arxiv.org/abs/1706.03175,_
2017.

Barret Zoph, Golnaz Ghiasi, Tsung-Yi Lin, Yin Cui, Hanxiao Liu, Ekin Dogus Cubuk, and Quoc Le.
Rethinking pre-training and self-training. Advances in Neural Information Processing Systems,
33, 2020.

Yang Zou, Zhiding Yu, BVK Kumar, and Jinsong Wang. Unsupervised domain adaptation for semantic segmentation via class-balanced self-training. In Proceedings of the European conference
_on computer vision (ECCV), pp. 289–305, 2018._


-----

## Appendix

A OVERVIEW OF THE PROOF TECHNIQUES

We first provide an overview of the techniques used in proving Theorems 1 and 2.

**1. Characterization of a proper population risk function. To characterize the performance of the**
iterative self-training algorithm via the stochastic gradient descent method, we need first to define
a population risk function such that the following two properties hold. First, the landscape of the
population risk function should be analyzable near {W [(][ℓ][)]}ℓ[L]=0[. Second, the distance between the]
empirical risk function in (1) and the population risk function should be bounded near {W [(][ℓ][)]}ℓ[L]=0[.]
The generalization function defined in (3), which is widely used in the supervised learning problem
with a sufficient number of samples, failed the second requirement. To this end, we turn to find a
new population risk function defined in (17), and the illustrations of the population risk function and
objection function are included in Figure 12.

**2. Local convex region of the population risk function. The purpose is to characterize the it-**
erations via the stochastic gradient descent method in the population risk function. To obtain the
local convex region of the population risk function, we first bound the Hessian of the population risk
function at its global optimal. Then, we utilize Lemma 12 in Appendix H.1 to obtain the Hessian of
the population risk function near the global optimal. The local convex region of the population risk
function is summarized in Lemma 1, and the proof of Lemma 1 is included in Appendix H.1.

**3. Bound between the population risk and empirical risk functions. After the characterization of**
the iterations via the stochastic gradient descent method in the population risk function, we need to
bound the distance between the population risk function and empirical risk function. Therefore, the
behaviors of the iterations via the stochastic gradient descent method in the empirical risk function
can be described by the ones in the population risk function and the distance between these two. The
key lemma is summarized in Lemma 2 (see Appendix H.2), and the proof is included in Appendix
H.2.

|Col1|Col2|Col3|n|Col5|
|---|---|---|---|---|
||||||
|||of 𝑓̂ 𝒟𝑓𝒟near 𝑾(𝑾0,0) 𝜂𝜂𝜂 𝜂𝑓̂𝑓 𝒟𝒟 𝛽𝛽(𝑾𝑾0,1 −|𝑾𝑾(0,0))|Objective function: 𝑓̂ 𝒟𝑓𝒟(𝑾)𝑾|
||||0,𝑇𝑇)𝑾𝑾[||



Figure 12: The landscapes of the objection function and population risk function.

In the following contexts, the details of the iterative self-training algorithm are included in Appendix
B. We then first provide the proof of Theorem 2 in Appendix E, which can be viewed as a special
case of Theorem 1. Then, with the preliminary knowledge from proving Theorem 2, we turn to
present the full proof of a more general statement summarized in Theorem 3 (see Appendix F),
which is related to Theorem 1. The definition and relative proofs of µ and ρ are all included in
Appendix G. The proofs of preliminary lemmas are included in Appendix H.

B ITERATIVE SELF-TRAINING ALGORITHM

In this section, we implement the details of the mini-batch stochastic gradient descent used in each
stage of the iterative self-training algorithm. After t number of iterations via mini-batch stochastic


-----

gradient descent at ℓ-th stage of self-training algorithm, the learned model is denoted as W [(][ℓ,t][)]. One
can easily check that W [(][ℓ][)] in the main context is denoted as W [(][ℓ,][0)] in this section and the following
proofs. Last, the pseudo-code of the iterative self-training algorithm is summarized in Algorithm 1.

**Algorithm 1 Iterative Self-Training Algorithm**

**Input: labeled D = {(xn, yn)}n[N]=1[, unlabeled data][ e]D = {xm}m[M]=1[, and gradient step size][ η][;]**

**Initialization: preliminary teacher model with weights W** [(0][,][0)];

e


**Partition: randomly and independently pick data from D and** _D to form T subsets {Dt}t[T]=0[ −][1]_ [and]
_{Dt}t[T]=0[ −][1][, respectively;]_

[e]

**for ℓ** = 0, 1, _, L_ 1 do

[e] _· · ·_ _−_


_ym = g(W_ [(][ℓ,][0)]; **_xm) for m = 1, 2, · · ·, M_**

**for t = 0, 1,** _, T_ 1 do
_· · ·_ e _−_

**_W_** [(][ℓ,t][+1)] = W [(][ℓ,t][)] _−_ _η · ∇f[ˆ]Dt,Dt_ [(][W][ (][ℓ,t][)][) +][ β][ ·] **_W_** [(][ℓ,t][)] _−_ **_W_** [(][ℓ,t][−][1)][]

**end for** e  

**_W_** [(][ℓ][+1][,][0)] = W [(][ℓ,T][ )]

**end for**

C NOTATIONS

In this section, we first introduce some important notations that will be used in the following proofs,
and the notations are summarized in Table 1.

As shown in Algorithm 1, W [(][ℓ,t][)] denotes the learned model after t number of iterations via minibatch stochastic gradient descent at ℓ-th stage of the iterative self-training algorithm. Given a student
model **_W, the pseudo label for_** **_x ∈_** _D[e] is generated as_

_y˜ = g(W[f] ;_ **_x)._** (16)

[f] e

Further, let W [[][p][]] = pW _[∗]_ + (1 − _p)W_ [(0][,][0)], we then define the population risk function as

e

2 _λ_ 2

_f_ (W ; p) = _[λ]2_ [E][x] _y[∗](p) −_ _g(W ; x)_ + 2 [E]x[e] _y[∗](p) −_ _g(W ;_ **_x)_** _,_ (17)

where y[∗](p) = g(W [[][p][]]; x) with x (0, δ[2]I) and _y[∗]e(p) =_ _g(W_ [[][p][]]; **_x) withx_** (0, _δ[˜][2]I)._
_∼N_ e e _∼N_
When p = 1, we have W [[][p][]] = W _[∗]_ and y[∗](p) = y for data in D.

Moreover, we use σi to denote the i-th largest singular value of e **_W_** _[∗]. Then, e κ is defined as e_ _σ1/σK,_
and γ = _i=1_ _[σ][i][/σ][K][. Additionally, to avoid high dimensional tensors, the first order derivative of]_
the empirical risk function is defined in the form of vectorized W as

[Q][K] _∂f_ _T_ _T_ _T_ _T_

_f_ (W ) = _, [∂f]_ _,_ _, [∂f]_ R[dK] (18)
_∇_ [ˆ] _∂w1_ _∂w2_ _· · ·_ _∂wK_ _∈_
h i

with W = [w1, w2, · · ·, wK] ∈ R[d][×][K]. Therefore, the second order derivative of the empirical risk function is in R[dk][×][dk]. Similar to (18), the high order derivatives of the population risk
functions are defined based on vectorized W as well. In addition, without special descriptions,
**_α = [α[T]1_** _[,][ α]2[T]_ _[,][ · · ·][,][ α]K[T]_ []][T][ stands for any unit vector that in][ R][dK][ with][ α][j][ ∈] [R][d][. Therefore, we have]

_[K]_ _∂f[ˆ]_ 2

_f_ 2 = max _f_ **_α_** 2 = max **_α[T]j_** _._ (19)
_∥∇[2][ ˆ]∥_ **_α_** _∥_ **_α_** _∂wj_

_[∥][α][T][ ∇][2][ ˆ]_  Xj=1 


-----

Finally, since we focus on order-wise analysis, some constant numbers will be ignored in the majority of the steps. In particular, we use h1(z) ≳ (or ≲, ≂)h2(z) to denote there exists some positive
constant C such that h1(z) ≥ (or ≤, =)C · h2(z) when z ∈ R is sufficiently large.

Table 3: Some Important Notations

|D = {x n, y n}N n=1|Labeled dataset with N number of samples;|
|---|---|
|De = {x em}M m=1|Unlabeled dataset with M number of samples;|
|Dt = {x n, y n}N n=t 1|a subset of D with N t number of labeled data;|
|Det = {x em}M m=t 1|a subset of De with M t number of unlabeled data;|
|d|Dimension of the input x orx; e|
|K|Number of neurons in the hidden layer;|
|W∗|Weights of the ground truth model;|
|W [p]|W [p] = pW ∗+ (1 −p)W (0,0);|
|W (ℓ,t)|Model returned by iterative self-training after t step mini-batch stochastic gradient de- scent at stage ℓ; W (0,0) is the initial model;|
|fˆ ( or fˆ) D, De|The empirical risk function defined in (1);|
|f(W ; p)|The population risk function defined in (17);|
|λˆ|The value of λδ2/(λδ2 + λeδ˜2);|
|µ|λδ2+λeδ˜2 The value of ; λρ(δ)+λeρ(δ˜)|
|σ i|The i-th largest singular value of W∗;|
|κ|The value of σ /σ ; 1 K|
|γ|The value of QK σ i/σ K; i=1|
|q|Some large constant in R+;|



D PRELIMINARY LEMMAS

We will first start with some preliminary lemmas. As outlined at the beginning of the supplementary
material, Lemma 1 illustrates the local convex region of the population risk function, and Lemma
2 explains the error bound between the population risk and empirical risk functions. Then, Lemma
3 describes the returned initial model W [(0][,][0)] via tensor initialization method (Zhong et al., 2017)
purely using labeled data. Next, Lemma 4 is the well known Weyl’s inequality in the matrix setting.
Moreover, Lemma 5 is the concentration theorem for independent random matrices. The definitions
of the sub-Gaussian and sub-exponential variables are summarized in Definitions 1 and 2. Lemmas
6 and 7 serve as the technical tools in bounding matrix norms under the framework of the confidence
interval.

**Lemma 1. Given any W ∈** R[d][×][K], let p satisfy

_σK_
_p ≲_ _._ (20)

_µ[2]K_ **_W_** **_W_** _F_
_· ∥_ _−_ _[∗]∥_


_Then, we have_


_λρ(δ) +_ _λρ(δ[˜])_ _λδ[˜][2])_

_f_ (W ; p)
12κ[2]γK[e] [2] _⪯∇[2]_ _⪯_ [7(][λδ][2]K[ +][ e]


(21)


-----

**Lemma 2. Let f and** _f[ˆ] be the functions defined in (17) and (1), respectively. Suppose the pseudo_
_label is generated through (16) with weights_ **_W . Then, we have_**

_d log q_ _λδ[˜][2]_ _d log q_

_∥∇f_ (W ) −∇f[ˆ](W )∥2 ≲ _[λδ]K[2]_ _N_ _· ∥[f]W −_ **_W_** _[∗]∥_ + _K_ _M_ _· ∥W −_ **_W[f] ∥2_**

r r (22)

e

_λδ[2]_ **_W_** **_W_** [[][p][]][] + _λδ[˜][2]_ **_W_** **_W_** [[][p][]][]

+ _·_ _−_ _·_ _[∗]_ _−_ 2

2K

 f [e]  

_with probability at least 1 −_ _q[−][d]._

**Lemma 3 (Initialization, (Zhong et al., 2017)). Assuming the number of labeled data satisfies**

_N ≥_ _p[2]N_ _[∗]_ (23)

_for some large constant q and p ∈_ [ _K[1]_ _[,][ 1]][, the tensor initialization method, which is summarized in]_

_Appendix I, outputs W_ [(0][,][0)] _such that_

**_W_** [(0][,][0)] **_W_** _F_ _σK_ (24)
_∥_ _−_ _[∗]∥_ _≤_ _p_ _c(κ)µ[2]K_

_·_

_with probability at least 1 −_ _q[−][d]._

**Lemma 4 (Weyl’s inequality, (Bhatia, 2013)). Let B = A + E be a matrix with dimension m × m.**
_Let λi(B) and λi(A) be the i-th largest eigenvalues of B and A, respectively. Then, we have_

_λi(B)_ _λi(A)_ **_E_** 2, _i_ [m]. (25)
_|_ _−_ _| ≤∥_ _∥_ _∀_ _∈_

**Lemma 5 ((Tropp, 2012), Theorem 1.6). Consider a finite sequence {Zk} of independent, random**
_matrices with dimensions d1_ _d2. Assume that such random matrix satisfies_
_×_

E(Zk) = 0 _and_ _∥Zk∥≤_ _R_ _almost surely._
_Define_
_δ[2]_ := max E(ZkZk[∗][)] _,_ E(Zk[∗][Z][k][)] _._
n X X o


_Then for all t ≥_ 0, we have

_Prob_


_t[2]/2_
(d1 + d2) exp _−_
_≤_ _δ[2]_ + Rt/3



_Prob_ **_Zk_** (d1 + d2) exp _−_ _._

( Xk _[≥]_ _[t])_ _≤_  _δ[2]_ + Rt/3 

**Definition 1 (Definition 5.7, (Vershynin, 2010)). A random variable X is called a sub-Gaussian**
_random variable if it satisfies_
(E|X|[p])[1][/p] _≤_ _c1√p_ (26)

_for all p ≥_ 1 and some constant c1 > 0. In addition, we have

Ee[s][(][X][−][E][X][)] _≤_ _e[c][2][∥][X][∥]ψ[2]_ 2 _[s][2]_ (27)

_for all s ∈_ R and some constant c2 > 0, where ∥X∥φ2 is the sub-Gaussian norm of X defined as
_X_ _ψ2 = supp_ 1 p[−][1][/][2](E _X_ )[1][/p].
_∥_ _∥_ _≥_ _|_ _|[p]_

_Moreover, a random vector X ∈_ R[d] _belongs to the sub-Gaussian distribution if one-dimensional_
_marginal α[T]_ **_X is sub-Gaussian for any α ∈_** R[d], and the sub-Gaussian norm of X is defined as
**_X_** _ψ2 = sup_ **_α_** 2=1 **_α[T]_** **_X_** _ψ2_ _._
_∥_ _∥_ _∥_ _∥_ _∥_ _∥_

**Definition 2 (Definition 5.13, (Vershynin, 2010)). A random variable X is called a sub-exponential**
_random variable if it satisfies_
(E|X|[p])[1][/p] _≤_ _c3p_ (28)

_for all p ≥_ 1 and some constant c3 > 0. In addition, we have

Ee[s][(][X][−][E][X][)] _≤_ _e[c][4][∥][X][∥]ψ[2]_ 1 _[s][2]_ (29)

_for s ≤_ 1/∥X∥ψ1 and some constant c4 > 0, where ∥X∥ψ1 is the sub-exponential norm of X
_defined as_ _X_ _ψ1 = supp_ 1 p[−][1](E _X_ )[1][/p].
_∥_ _∥_ _≥_ _|_ _|[p]_


**_Zk_**


-----

**Lemma 6 (Lemma 5.2, (Vershynin, 2010)). Let B(0, 1) ∈{α** _∥α∥2 = 1, α ∈_ R[d]} denote a
_unit ball in R[d]. Then, a subset Sξ is called a ξ-net of B(0, 1) if every point z ∈B(0, 1) can be_
_approximated to within ξ by some point α_ (0, 1), i.e., **_z_** **_α_** 2 _ξ. Then the minimal_
_cardinality of a ξ-net Sξ satisfies_ _∈B_ _∥_ _−_ _∥_ _≤_
_ξ_ (1 + 2/ξ)[d]. (30)
_|S_ _| ≤_

**Lemma 7 (Lemma 5.3, (Vershynin, 2010)). Let A be an d1 × d2 matrix, and let Sξ(d) be a ξ-net**
_of B(0, 1) in R[d]_ _for some ξ ∈_ (0, 1). Then

**_A_** 2 (1 _ξ)[−][1]_ max 1 **_[Aα][2][|][.]_** (31)
_∥_ _∥_ _≤_ _−_ **_α1∈Sξ(d1),α2∈Sξ(d2)_** _[|][α][T]_

**Lemma 8 (Mean Value Theorem). Let U ⊂** R[n][1] _be open and f : U −→_ R[n][2] _be continuously_
_differentiable, and x ∈_ **_U_** _, h ∈_ R[n][1] _vectors such that the line segment x + th, 0 ≤_ _t ≤_ 1 remains
_in U_ _. Then we have:_

1
**_f_** (x + h) − **_f_** (x) = 0 _∇f_ (x + th)dt _· h,_
Z 

_where ∇f denotes the Jacobian matrix of f_ _._

E PROOF OF THEOREM 2

With p = 1 in (17), the population risk function is reduced as


_λ_

_f_ (W ) = _[λ]_ **_x[(]y[e][∗]_** _g(W ;_ **_x)),_** (32)

2 [E][x][(][y][ −] _[g][(][W][ ;][ x][)) +]_ 2 [E][e] _−_
e

where y = g(W ; x) with x (0, δ[2]I) and _y[∗]_ = g(W ; **_x) with_** **_x_** (0, _δ[˜][2]I). In fact,_

_[∗]_ _∼N_ _[∗]_ e _∼N_
(32) can be viewed as the expectation of the empirical risk function in (1) given _ym = g(W_ _[∗];_ **_xm)._**
Moreover, the ground-truth model W _[∗]_ is the global optimal to (32) as well. Lemmas 9 and 10 e e e
are the special case of Lemmas 1 and 2 with p = 1. The proof of Theorem 2 is followed by the
e e
presentation of the two lemmas.

The main idea in proving Theorem 2 is to characterize the gradient descent term by the MVT in
Lemma 8 as shown in (36) and (37). The IVT is not directly applied in the empirical risk function because of its non-smoothness. However, the population risk functions defined in (17) and
(32), which are the expectations over the Gaussian variables, are smooth. Then, as the distance
_∥∇f_ (W ) −∇f (W _[∗])∥F is upper bounded by a linear function of ∥W −_ **_W_** _[∗]∥F as shown in (47),_
we can establish the connection between ∥W [(][ℓ,t][+1)] _−_ **_W_** _[∗]∥F and ∥W_ [(][ℓ,t][)] _−_ **_W_** _[∗]∥F as shown in_
(50). Finally, by mathematical induction over ℓ and t, one can characterize ∥W [(][L,][0)] _−_ **_W_** _[∗]∥F by_
_∥W_ [(0][,][0)] _−_ **_W_** _[∗]∥F as shown in (52), which completes the whole proof._

**Lemma 9 (Lemma 1 with p = 1). Let f and** _f[ˆ] are the functions defined in (32) and (1), respectively._
_Then, for any W that satisfies,_
**_W_** **_W_** _F_ (33)
_∥_ _−_ _[∗]∥_ _≤_ _µ[σ][2][K]K [,]_

_we have_
_λρ(δ) +_ _λρ(δ[˜])_ _λδ[˜][2])_

_f_ (W ) _._ (34)

**Lemma 10 (Lemma 2 with p = 112κ[2])γK. Let[e]** [2] f and⪯∇f[ˆ] be the functions defined in[2] _⪯_ [7(][λδ][2]K[ +][ e] (32) and (1), respectively.
_Suppose the pseudo label is generated through (16) with weights_ **_W . Then, we have_**

_λδ2_ _d log q_ _δ[2]_ _d log q_
_∥∇f_ (W ) −∇f[ˆ](W )∥2 ≲ _K_ _N_ + [(1][ −]K[λ][)˜] [f]M _· ∥W −_ **_W_** _[∗]∥2_

r r (35)

 

+ [(1][ −] _[λ][)˜]δ[2]_ _d log q_ + [1] **_W_** **_W_** 2

_K_ _M_ 2 _· ∥_ [f] − _[∗]∥_

[r] 

_with probability at least 1 −_ _q[−][d]._


-----

_Proof of Theorem 2. From Algorithm 1, in the ℓ-th outer loop, we have_

**_W_** [(][ℓ,t][+1)] =W [(][ℓ,t][)] _−_ _η∇f[ˆ]Dt,Dt_ [(][W][ (][ℓ,t][)][) +][ β][(][W][ (][ℓ,t][)][ −] **_[W][ (][ℓ,t][−][1)][)]_**

=W [(][ℓ,t][)] _η_ _f_ (W [(][ℓ,t][)]) + β(W [(][ℓ,t][)] **_W_** [(][ℓ,t][−][1)]) (36)

e

_−_ _∇_ _−_

+ η · _∇f_ (W [(][ℓ,t][)]) −∇f[ˆ]Dt,Dt [(][W][ (][ℓ,t][)][)] _._

Since ∇f is a smooth function and  W _[∗]_ is a local (global) optimal to e _f_, then we have

_∇f_ (W [(][ℓ,t][)]) =∇f (W [(][ℓ,t][)]) −∇f (W _[∗])_

1 (37)

= 0 _∇[2]f_ **_W_** [(][ℓ,t][)] + u · (W [(][ℓ,t][)] _−_ **_W_** _[∗])_ _du · (W_ [(][ℓ,t][)] _−_ **_W_** _[∗]),_

Z  

where the last equality comes from MVT in Lemma 8. For notational convenience, we use H [(][ℓ,t][)]
to denote the integration as

1
**_H_** [(][ℓ,t][)] := 0 _∇[2]f_ **_W_** [(][ℓ,t][)] + u · (W [(][ℓ,t][)] _−_ **_W_** _[∗])_ _du._ (38)
Z  


Then, we have
**_W_** [(][ℓ,t][+1)] _−_ **_W_** _[∗]_ = **_I −_** _ηH_ [(][ℓ,t][)] _βI_ **_W_** [(][ℓ,t][)] _−_ **_W_** _[∗]_
" **_W_** [(][ℓ,t][)] **_W_** # " **_I_** **0** # "W [(][ℓ,t][−][1)] **_W_**

_−_ _[∗]_ _−_ _[∗]_

+ η _∇f_ (W [(][ℓ,t][)]) −∇f[ˆ]Dt,Dt [(][W][ (][ℓ,t][)][)]

" **0**
e

Let H [(][ℓ,t][)] = SΛS[T] be the eigen-decomposition of H [(][ℓ,t][)]. Then, we define


(39)

(40)

share the same


**_S[T]_**


**_I −_** _ηΛ + βI_ _βI_


**_A(β) :=_**


**_A(β)_**


**_S[T]_**


**_S[T]_**
# " **0**


**_I −_** _ηΛ + βI_ _βI_


Since


, we know A(β) and


**_S[T]_**


eigenvalues. Let γi[(][Λ][)] be the i-th eigenvalue of _f_ (w[(][t][)]), then the corresponding i-th eigenvalue
_∇[2]_
of (40), denoted by γi[(][A][)], satisfies
b

(γi[(][A][)](β))[2] (1 _ηγi[(][Λ][)]_ + β)γi[(][A][)](β) + β = 0. (41)
_−_ _−_

By simple calculation, we have

2

_√β,_ if _β_ 1 _ηγi[(][Λ][)]_ _,_

_|γi[(][A][)](β)| =_  21 _i_ + ≥ β ) + − q(1 − _ηγi[(][Λ][)]_ + β)[2] _−_ 4β _[,][ otherwise][.]_ (42)

q

Specifically, we have  [(1][ −] _[ηγ][(][Λ][)]_

_γi[(][A][)](0) > γi[(][A][)](β),_ for _β_ 0, (1 _ηγi[(][Λ][)])[2][],_ (43)
_∀_ _∈_ _−_

2

 

and γi[(][A][)] achieves the minimum γi[(][A][)][∗] = 1 _ηγi[(][Λ][)]_ when β = 1 _ηγi[(][Λ][)]_ . From Lemma
_−_ _−_

9, for any a ∈ R[d] with ∥a∥2 = 1, we have q  q 

1 1
**_a[T]_** _∇f_ (W [(][ℓ,t][)])a = 0 **_a[T]_** _∇[2]f_ **_W_** [(][ℓ,t][)] + u · (W [(][ℓ,t][)] _−_ **_W_** _[∗])_ **_adu ≤_** 0 _γmax∥a∥2[2][du][ =][ γ][max][,]_
Z 1   Z 1

**_a[T]_** _∇f_ (W [(][ℓ,t][)])a = 0 **_a[T]_** _∇[2]f_ **_W_** [(][ℓ,t][)] + u · (W [(][ℓ,t][)] _−_ **_W_** _[∗])_ **_adu ≥_** 0 _γmin∥a∥2[2][du][ =][ γ][min][,]_
Z   Z (44)


-----

where γmax = [7(][λδ][2]K[+]λ[e]δ[˜][2]), and γmin = _[λρ]12[(][δ]κ[)+][2]γKλρ[e]_ ([2]δ[˜][ . Therefore, we have])

_λρ(δ[˜])_ _λδ[˜][2])_
_γmin[(][Λ][)]_ [=][ λρ][(][δ][) +][ e] _,_ and _γmax[(][Λ][)]_ [= 7(][λδ][2][ +][ e] _._

12κ[2]γK [2] _K_

Thus, we can select η = _√γmax[(][Λ][)]_ [+]1 _γmin[(][Λ][)]_ 2, and ∥A(β)∥2 can be bounded by
  q 

_λρ(δ) +_ _λρ(δ[˜])_ _λδ[˜][2])_

min _/_ 2 [7(][λδ][2][ +][ e]
_β_ s 12κ[2]γK [2] _·_ _K_

_[∥][A][(][β][)][∥][2][ ≤][1][ −]_

  [e]   

_µ(δ,_ _δ[˜])_
=1 − 168κ[2]γK _,_

1/2

where µ(δ, _δ[˜]) =_ _λρ(δ)+λρ[e]_ (δ[˜]) . p

_λδ[2]+λ[e]δ[˜][2]_

 

From Lemma 10, we have


(45)

(46)

(47)

(48)

(49)


_λδ2_
_f_ (W [(][ℓ,t][)]) _f_ (W [(][ℓ,t][)]) 2 =
_∥∇_ _−∇_ [ˆ] _∥_ _K_


_λδ[˜][2]_


_d log q_ _λδ[˜][2]_

+
_Nt_ _K_
e

_d log q_ + [1]

_Mt_ 2

[r]


_d log q_

_Mt_


**_W_** [(][ℓ,t][)] **_W_** 2

_· ∥_ _−_ _[∗]∥_


**_W_** [(][ℓ,][0)] **_W_** 2.

_· ∥_ _−_ _[∗]∥_


Given ε > 0 and ˜ε > 0 with ε + ˜ε < 1, let

_η_ _[λδ][2]_
_·_ _K_

r

_λδ[˜][2]_
and _η_
_·_ _K_
e

where we need


_d log q_ _εµ(δ,_ _δ[˜])_

,

_Nt_ _≤_ 168κ[2]γK

_d log q_ p _εµ˜_ (δ, _δ[˜])_

_Mt_ _≤_ 168κ[2]γK

r

p


_Nt_ _ε[−][2]µ[−][2][ ]_ _λδ[2]_ 2κ2γK 3d log q,
_≥_ _λδ[2]_ + _λδ[˜][2]_

(49)



and _Mt_ _ε˜[−][2]µ[−][2][ ]_ _λδ[˜][2]_ 2κ2γK 3d log q.
_≥_ _λδ[2]_ [e]+ _λδ[˜][2]_
e 

Therefore, from (46), (47) and (48), we have

[e]

**_W_** [(][ℓ,t][+1)] **_W_** 2
_∥_ _−_ _[∗]∥_

_ε)µ(δ,_ _δ[˜])_ _λδ[˜][2]_ _d log q_
_≤_ 1 − [(1][ −] _[ε]168[ −]_ _κ[˜][2]γK_ _∥W_ [(][ℓ,t][)] _−_ **_W_** _[∗]∥2 + η ·_ _K_ _Mt_ + [1]2 _· ∥W_ [(][ℓ,][0)] _−_ **_W_** _[∗]∥2_
  e [r] 
p _ε)µ(δ,_ _δ[˜])_ _λδ[˜][2]_

_≤_ 1 − [(1][ −] _[ε]168[ −]_ _κ[˜][2]γK_ _∥W_ [(][ℓ,t][)] _−_ **_W_** _[∗]∥2 + η ·_ _K_
  e _[∥][W][ (][ℓ,][0)][ −]_ **_[W][ ∗][∥][2]_** (50)
p

when M ≥ 4d log q. By mathematical induction on (50) over t, we have

**_W_** [(][ℓ,t][)] **_W_** 2
_∥_ _−_ _[∗]∥_

_ε)µ_ _t_
1 **_W_** [(][ℓ,][0)] **_W_** 2
_≤_ _−_ [(1][ −]168[ε][ −]κ[2]γK[˜] _· ∥_ _−_ _[∗]∥_
 

168p _κ[2]γK_ _√K_ _λδ[˜][2]_ (51)

+

(1p − _ε −_ _ε˜)µ_ _[·]_ 14(λδ[2] + _λδ[˜][2])_ _·_ _K_ _[∥][W][ (][ℓ,][0)][ −]_ **_[W][ ∗][∥][2]_**

e

_ε)µ_ _t_ _κ[2]γλ[e]δ[˜][2]_
1 + **_W_** [(][ℓ,][0)] **_W_** 2
_≤_ _−_ [(1][ −]168[ε][ −]κ[2]γK[˜]  (1 −[e] _ε −pε˜)µ(λδ[2]_ + _λδ[˜][2])_  _· ∥_ _−_ _[∗]∥_
p

[e]


-----

By mathematical induction on (51) over ℓ, we have


**_W_** [(][ℓ,T][ )] **_W_** 2
_∥_ _−_ _[∗]∥_

_ε)µ_ _T_
1 − [(1][ −]168[ε][ −]κ[2]γK[˜]
 
p


_ℓ_ (52)
**_W_** [(0][,][0)] **_W_** 2

_· ∥_ _−_ _[∗]∥_



_κ[2]γλ[e]δ[˜][2]_

(1 _ε_ pε˜)µ(λδ[2] + _λδ[˜][2])_
_−_ _−_ [e]


F PROOF OF THEOREM 1

Instead of proving Theorem 1, we turn to prove a stronger version, as shown in Theorem 3. One can
verify that Theorem 1 is a special case of Theorem 3 by selecting _λ[ˆ] in the order of p and_ _ε is in the_
order of (2p − 1).

The major idea in proving Theorem 3 is similar to that of Theorem 2. The first step is to characterize e
the gradient descent term on the population risk function by the MVT in Lemma 8 as shown in
(58) and (59). Then, the connection between ∥W [(][ℓ][+1][,][0)] _−_ **_W_** [[][p][]]∥F and ∥W [(][ℓ,][0)] _−_ **_W_** [[][p][]]∥F are
characterized in (64). Compared with proving Theorem 2, where the induction over ℓ holds naturally
with large size of labeled data, the induction over ℓ requires a proper value of p as shown in (69). By
induction over ℓ on (64), the relative error ∥W [(][L,][0)] _−_ **_W_** [[][p][]]∥F can be characterized by ∥W [(0][,][0)] _−_
**_W_** [[][p][]]∥F as shown in (71).

**Theorem 3. Suppose the initialization W** [(0][,][0)] _satisfies with_

_ε)p_ 1
_p_ _λ_ _−_ (53)
_|_ _−_ [ˆ]| ≤ [2(1][ −]µ√[e]K

_for some constant_ _ε ∈_ (0, 1/2), where
e _λˆ :=_ _λδ[2]_ _N_ [1]2 (54)

_λδ[2]_ + _λδ[˜][2][ =]_ _κ[2]γK_ [3]µ[2]d log q
  

_and_

[e] _λδ[2]_ + _λδ[˜][2]_

_µ = µ(δ,_ _δ[˜]) =_ _._ (55)

_λρ(δ) +_ _λρ(δ[˜])_

[e]

_Then, if the number of samples in_ _D further satisfies_

_M ≳[e]_ _ε˜[−][2]κ[2]γµ[2][ ]1 −_ _λ[ˆ]_ 2K[e]3d log q, (56)

_the iterates {W_ [(][ℓ,t][)]}ℓ,t[L,T]=0 _[converge to][ W][ [][p][]][ with][ p][ satisfies]_ [ (53)][ as]

lim
_T →∞_ _[∥][W][ (][ℓ,T][ )][ −]_ **_[W][ [][p][]][∥][2]_**

_≤_ 1 1 _ε˜_ 1 − _p[∗]_ + µ√K (ˆλ − _p[∗])_ _· ∥W_ [(0][,][0)] _−_ **_W_** _[∗]∥2 +_ (1 _ε˜_ _ε˜)_ (57)

_−_ _[·]_   _−_ _[· ∥][W][ (][ℓ,][0)][ −]_ **_[W][ [][p][]][∥][2][,]_**

_with probability at least 1 −_ _q[−][d]._


_Proof of Theorem 3. From Algorithm 1, in the ℓ-th outer loop, we have_

**_W_** [(][ℓ,t][+1)] =W [(][ℓ,t][)] _−_ _η∇f[ˆ]Dt,Dt_ [(][W][ (][ℓ,t][)][) +][ β][(][W][ (][ℓ,t][)][ −] **_[W][ (][ℓ,t][−][1)][)]_**

=W [(][ℓ,t][)] _η_ _f_ (W e[(][ℓ,t][)]) + β(W [(][ℓ,t][)] **_W_** [(][ℓ,t][−][1)]) (58)
_−_ _∇_ _−_

+ η · _∇f_ (W [(][ℓ,t][)]) −∇f[ˆ]Dt,Dt [(][W][ (][ℓ,t][)][)]
 

Since ∇f is a smooth function and W [[][p][]] is a local (global) optimal to e _f_, then we have

_∇f_ (W [(][ℓ,t][)]) =∇f (W [(][ℓ,t][)]) −∇f (W [[][p][]])

1 (59)
= 0 _∇[2]f_ **_W_** [(][ℓ,t][)] + u · (W [(][ℓ,t][)] _−_ **_W_** [[][p][]]) _du · (W_ [(][ℓ,t][)] _−_ **_W_** [[][p][]]),
Z  


-----

where the last equality comes from Lemma 8.

Similar to the proof of Theorem 2, we have

_∥W_ [(][ℓ,t][+1)]−W [[][p][]]∥2 ≤∥A(β)∥2·∥W [(][ℓ,t][)]−W [[][p][]]∥2+η·∥∇f (W [(][ℓ,t][)])−∇f[ˆ]Dt,Dt [(][W][ (][ℓ,t][)][)][∥][2][.][ (60)]

From Lemma 2, we have

e


_f_ (W [(][ℓ,t][)]) _f_ (W [(][ℓ,t][)]) 2
_∥∇_ _−∇_ [ˆ] _∥_

_d log q_ _λδ[˜][2]_

≲ _[λδ]K[2]_ _Nt_ _· ∥W_ [(][ℓ,t][)] _−_ **_W_** _[∗]∥_ + _K_

r

e


_d log q_

**_W_** [(][ℓ,t][)] **_W_** [(][ℓ,][0)] 2
_Mt_ _· ∥_ _−_ _∥_


(61)

(62)

(63)


+ _λδ[2]_ _· (W_ [(0][,][0)] _−_ **_W_** [[][p][]]) − _λδ[˜][2]_ _· (W_ _[∗]_ _−_ **_W_** [[][p][]])

_K_

e

When ℓ = 0, following the similar steps from (41) to (46), we have


_f_ (W [(][ℓ,t][)]) _f_ (W [(][ℓ,t][)]) 2
_∥∇_ _−∇_ [ˆ] _∥_

_d log q_ _λδ[˜][2]_

≲ _[λδ][2]_ **_W_** [(][ℓ,t][)] **_W_** [[][p][]] +

_K_ _Nt_ _· ∥_ _−_ _∥_ _K_

r

e


_d log q_

**_W_** [(][ℓ,t][)] **_W_** [[][p][]] 2
_Mt_ _· ∥_ _−_ _∥_

_d log q_

**_W_** [(0][,][0)] **_W_** [[][p][]] 2
_Mt_ _· ∥_ _−_ _∥_


_d log q_ _λδ[˜][2]_

_Nt_ _· ∥W_ _[∗]_ _−_ **_W_** [[][p][]]∥ + _K_
e


+ _[λδ][2]_


_λδ[2]_ _· (1 −_ _p) −_ _λδ[˜][2]_ _· p_

_K_

e


**_W_** [(0][,][0)] **_W_** 2

_· ∥_ _−_ _[∗]∥_


and


**_W_** [(][ℓ,t][+1)] **_W_** [[][p][]] 2
_∥_ _−_ _∥_

1 _ε˜_
1 _−_
_−_ _µ(δ,_ _δ[˜])_ 154κ[2]γK


p


**_W_** [(][ℓ,t][)] **_W_** [[][p][]] 2

_· ∥_ _−_ _∥_


_λδ2(1_ _p)_
+ η _−_
_·_ _K_


_ελ[e]δ[˜][2]_ _p_
+ η [˜] _·_
_·_ _K_ _·_

r

Therefore, we have


_d log q_ + _λδ[2]_ _· (1 −_ _p) −_ _λδ[˜][2]_ _· p_

_Nt_ _K_

r

e

_d log q_

**_W_** [(0][,][0)] **_W_** 2.
_Mt_ _∥_ _−_ _[∗]∥_


**_W_** [(0][,][0)] **_W_** 2

_· ∥_ _−_ _[∗]∥_


lim
_T →∞_ _[∥][W][ (][ℓ,T][ )][ −]_ **_[W][ [][p][]][∥][2]_**

154κ[2]γK _λδ2(1_ _p)_ _d log q_ _λδ[2]_ (1 _p)_ _λδ[˜][2]_ _p_

_η_ _−_ + _·_ _−_ _−_ _·_ **_W_** [(0][,][0)] **_W_** 2

_≤_ _[µ]_ 1 _ε˜_ _·_ _·_ _K_ _Nt_ _K_ _· ∥_ _−_ _[∗]∥_
p _−_ h r e 

_ελ[e]δ[˜][2]_ _p_ _d log q_
+ [˜] _·_ **_W_** [(0][,][0)] **_W_** 2

_K_ _·_ _Mt_ _· ∥_ _−_ _[∗]∥_

r

154κ[2]γK _K_ _λδ2(1 −_ _p)_ _d log q_ + _λδ[2]_ _· (1i_ _−_ _p) −_ _λδ[˜][2]_ _· p_

_≤_ _[µ]p_ 1 − _ε˜_ _·_ 14(λδ[2] + _λδ[˜][2])_ _·_ h _K_ r _Nt_ _K_ e 

_ελ[e]δ[˜][2]_ _p_ _d log q_

_· ∥[e]W_ [(0][,][0)] _−_ **_W_** _[∗]∥2 + [˜]_ _K_ _·_ _·_ _Mt_ _· ∥W_ [(0][,][0)] _−_ **_W_** _[∗]∥2_

r

1 i

1 _p +_ _√K_ (1 _p)µλˆ_ _pµ(1_ _λ)_ **_W_** [(0][,][0)] **_W_** 2

_≃_ 1 _ε˜_ _−_ _·_ _−_ _−_ _−_ [ˆ] _· ∥_ _−_ _[∗]∥_

_−_ _εp˜_ _[·]_  

+

(1 − _ε˜)_ _[· ∥][W][ (0][,][0)][ −]_ **_[W][ ∗][∥][2]_**

= 1 1 _ε˜_ 1 − _p + µ√K_ _λ −_ _p_ _· ∥W_ [(0][,][0)] _−_ **_W_** _[∗]∥2 +_ (1 _εp˜_ _ε˜)_

_−_ _[·]_   _−_ _[· ∥][W][ (0][,][0)][ −]_ **_[W][ ∗][∥][2][,]_** (64)

b

where _λ[ˆ] =_ _λδ[2]_

_λδ[2]+λ[e]δ[˜][2][ .]_


-----

To guarantee the convergence in the outer loop, we require

lim
_T →∞_ _[∥][W][ (][ℓ,T][ )][ −]_ **_[W][ [][p][]][∥][2][ ≤∥][W][ (0][,][0)][ −]_** **_[W][ [][p][]][∥][2][ =][ p][∥][W][ (0][,][0)][ −]_** **_[W][ ∗][∥][2][,]_** (65)

and lim
_T →∞_ _[∥][W][ (][ℓ,T][ )][ −]_ **_[W][ ∗][∥][2][ ≤∥][W][ (0][,][0)][ −]_** **_[W][ ∗][∥][2][.]_**

Since we have

_∥W_ [(][ℓ,T][ )] _−_ **_W_** [[][p][]]∥2 ≤∥W [(][ℓ,T][ )] _−_ **_W_** _[∗]∥2 + ∥W_ _[∗]_ _−_ **_W_** [[][p][]]∥2 (66)

=∥W [(][ℓ,T][ )] _−_ **_W_** _[∗]∥2 + (1 −_ _p) · ∥W_ _[∗]_ _−_ **_W_** [(0][,][0)]∥2,

it is clear that (65) holds if and only if


1

1 _p +_ _εp + µ√K_ _λˆ_ _p_ + 1 _p_ 1. (67)
1 _ε˜_ _−_ _−_ _−_ _≤_
_−_ _[·]_  

To guarantee the iterates strictly converges to the desired point, we let

e


_λˆ_ _p_ + 1 _p_ 1
_−_ _−_ _≤_ _−_ _C[1]_



(68)

(69)


1 _p +_ _εp + µ_ _K_
1 _ε˜_ _−_
_−_ _[·]_ 

for some larger constant C, which is equivalent to

e


_ε)p_ 1
_p_ _λ_ _−_
_|_ _−_ [ˆ]| ≤ [2(1][ −]µ√[e]K

To make the bound in (69) meaningful, we need


1
_p_ (70)
_≥_ 2(1 _ε)_ _[.]_

When ℓ> 1, following similar steps in (64), we have − e

lim
_T →∞_ _[∥][W][ (][ℓ,T][ )][ −]_ **_[W][ [][p][]][∥][2]_**

(71)

_≤_ 1 1 _ε˜_ 1 − _p + µ√K_ (ˆλ − _p)_ _· ∥W_ [(0][,][0)] _−_ **_W_** _[∗]∥2 +_ 1 _εp˜_ _ε˜_

_−_ _[·]_   _−_ _[· ∥][W][ (][ℓ,][0)][ −]_ **_[W][ [][p][]][∥][2][,]_**

Given (69) holds, from (71), we have

lim
_L→∞,T →∞_ _[∥][W][ (][L,T][ )][ −]_ **_[W][ [][p][]][∥][2]_**


_λˆ_ _p_ **_W_** [(0][,][0)] **_W_** 2
_−_ _· ∥_ _−_ _[∗]∥_


_λˆ_ _p_ **_W_** [(0][,][0)] **_W_** 2.
_−_ _· ∥_ _−_ _[∗]∥_



1 _p + µ_
1 _ε_ _−_
_−1_ _[·]_ 

1 _p + µ_
1 _εe_ _−_
_−_ _[·]_ 
e


(72)


G DEFINITION AND RELATIVE PROOFS OF ρ

In this section, the formal definition of ρ is included in Definition 3, and a corresponding claim about
_ρ is summarized in Lemma 11. One can quickly check that the ReLU activation function satisfies_
the conditions in Lemma 11.

The major idea in proving Lemma 11 is to show Hr(δ) and Jr(δ) in Definition 3 are in the order of
_δ[r]_ when δ is small.
**Definition 3. Let Hr(δ) = Ez** (0,δ2) _φ[′](σKz)z[r][]_ _and Jr(δ) = Ez_ (0,δ2) _φ[′][2](σKz)z[r][]. Then,_
_∼N_ _∼N_
_ρ = ρ(δ) is defined as_
   

_ρ(δ) = min_ _J0(δ) −_ _H0[2][(][δ][)][ −]_ _[H]1[2][(][δ][)][, J][2][(][δ][)][ −]_ _[H]1[2][(][δ][)][ −]_ _[H]2[2][(][δ][)][, H][0][(][δ][)][ ·][ H][2][(][δ][)][ −]_ _[H]1[2][(][δ][)]_ _, (73)_
n o

_where σK is the minimal singular value of W_ _[∗]._


-----

**Lemma 11 (Order analysis of ρ). If ρ(δ) > 0 for δ ∈** (0, ξ) for some positive constant ξ and the
_sub-gradient of ρ(δ) at 0 can be non-zero, then ρ(δ) = Θ(δ[2]) when δ →_ 0[+]. Typically, for ReLU
_activation function, µ in (5) is a fixed constant for all δ,_ _δ[˜] ≤_ 1.

_Proof of Lemma 11 . From Definition 3, we know that Hr(δ) = Ez_ (0,δ2)φ[′](σKz)z[r]. Suppose
_∼N_
we have Hr(δ) = Θ(δ[r]) and Jr(δ) = Θ(δ[r]), then from (73) we have


_J0(δ) −_ _H0[2][(][δ][)][ −]_ _[H]1[2][(][δ][)][ ∈]_ [Θ(1)][ −] [Θ(][δ][2][)][,]

_J2(δ) −_ _H1[2][(][δ][)][ −]_ _[H]2[2][(][δ][)][ ∈]_ [Θ(][δ][2][)][,]

_H0(δ) · H2(δ) −_ _H1[2][(][δ][)][ ∈]_ [Θ(][δ][2][)][ −] [Θ(][δ][4][)][.]


(74)


Because ρ is a continuous function with ρ(z) > 0 for some z > 0. Therefore, ρ ̸= J0(δ) − _H0[2][(][δ][)][ −]_
_H1[2][(][δ][)][ when][ δ][ →]_ [0][+][, otherwise][ ρ][(][z][)][ <][ 0][ for any][ z >][ 0][. When][ δ][ →] [0][+][, both][ J][2][(][δ][)][ −] _[H]1[2][(][δ][)][ −]_
_H2[2][(][δ][)][ and][ H][0][(][δ][)][ ·][ H][2][(][δ][)][ −]_ _[H]1[2][(][δ][)][ are in the order of][ δ][2][, which indicates that][ µ][ is a fixed constant]_
when both δ and _δ[˜] are close to 0. In addition, J2(δ) −_ _H1[2][(][δ][)][ −]_ _[H]2[2][(][δ][)][ goes to][ +][∞]_ [while both]
_J0(δ) −_ _H0[2][(][δ][)][ −]_ _[H]1[2][(][δ][)][ and][ H][0][(][δ][)][ ·][ H][2][(][δ][)][ −]_ _[H]1[2][(][δ][)][ go to][ −∞]_ [when][ δ][ →] [+][∞][. Therefore, with a]
large enough δ, we have

_ρ(δ) ∈_ Θ(δ[2]) − Θ(δ[4]) or Θ(1) − Θ(δ[2]), (75)

which indicates that µ is a strictly decreasing function when δ and _δ[˜] are large enough._

Next, we provide the conditions that guarantee Hr(δ) = Θ(δ[r]) hold, and the relative proof for Jr(δ)
can be derived accordingly following the similar steps as well. From Definition 3, we have


_Hr(δ)_ +∞ _z_ _r_ 1
lim = lim _φ[′](σKz)_ _δ[2]_ _dz_
_δ_ 0[+] _δ[r]_ _δ_ 0[+] _δ_ _√2πδ [e][−]_ _[z][2]_
_→_ _→_ Z−∞

+   

(a) _∞_
= lim _φ[′](σKδt)_ _[t][r]_
_δ_ 0[+] _√2π [e][−][t][2]_ _[dt]_
_→_ Z−∞

0[−] +∞

= lim _φ[′](σKδt)_ _[t][r]_ _φ[′](σKδt)_ _[t][r]_
_δ→0[+]_ Z−∞ _√2π [e][−][t][2]_ _[dt][ + lim]δ→0[+]_ Z0[+] _√2π [e][−][t][2]_ _[dt]_

0[−] _t[r]_ +∞ _t[r]_
=φ[′](0[−]) Z−∞ _√2π [e][−][t][2]_ _[dt][ +][ φ][′][(0][+][)]_ Z0[+] _√2π [e][−][t][2]_ _[dt,]_


(76)


where equality (a) holds by letting t = _[z]δ_ [. It is easy to verify that]


+∞ _t[r]_ 0[−]
Z0[+] _√2π [e][−][t][2]_ _[dt][ = (][−][1)][r]_ Z−∞


_t[r]_

2π [e][−][t][2] _[dt,]_


and both are bounded for a fixed r. Thus, as long as either φ[′](0[−]) or φ[′](0[+]) is non-zero, we have
_Hr(δ) = Θ(δ[r]) when δ_ 0[+].
_→_

If φ has bounded gradient as |φ[′]| ≤ _Cφ for some positive constant Cφ. Then, we have_

+∞ _z_ _r_ 1
= _φ[′](σKz)_ _δ[2]_ _dz_
_δ[r]_ _δ_ _√2πδ [e][−]_ _[z][2]_
Z−∞

+   

_[H][r][(][δ][)]_ _∞_

= _φ[′](σKδt)_ _[t][r]_ (77)

_√2π [e][−][t][2]_ _[dt]_

Z−∞

+∞ _t[r]_
_Cφ_
_≤_ _·_ _√2π [e][−][t][2]_ _[dt]_
Z−∞

Therefore, we have Hr(δ) = (δ[r]) for all δ > 0 when φ has bounded gradient.
_O_

Typiclly, for ReLU function, one can directly calculate that Hr(δ) = δ[r] for δ ∈ R, and ρ(δ) = Cδ[2]
when δ ≤ 1 for some constant C = 0.091. Then, it is easy to check that µ is a constant when
_δ,_ _δ[˜] ≤_ 1.


-----

H PROOF OF PRELIMINARY LEMMAS

H.1 PROOF OF LEMMA 1

The eigenvalues of ∇[2]f (·; p) at any fixed point W can be bounded in the form of (80) by Weyl’s
inequality (Lemma 4). Therefore, the primary technical challenge lies in bounding ∥∇[2]f (W ; p) −
_f_ (W [[][p][]]; p) 2, which is summarized in Lemma 12. Lemma 13 provides the exact calulation of
_∇[2]_ _∥_ 2

the lower bound of Ex _Kj=1_ **_[α]j[T]_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** when x belongs to Gaussian distribution with
zero mean, which is used in proving the lower bound of the Hessian matrix in (81). P 

**Lemma 12. Let f** (W ; p) be the population risk function defined in (17) with p and W satisfying
(20). Then, we have


_δ[2]_
_f_ (W [[][p][]]; p) _f_ (W ; p) 2 ≲ _[λδ][2][ + (1][ −]_ _[λ][)˜]_
_∥∇[2]_ _−∇[2]_ _∥_ _K_


_._ (78)

_· [∥][W][ [][p]σ[]][ −]K_ **_[W][ ∥][2]_**


**Lemma 13 (Lemma D.6, (Zhong et al., 2017)). For any** **_wj_** _j=1_
_vector defined in (19). When the φ is ReLU function, we have {_ _}[K]_ _[∈]_ [R][d][, let][ α][ ∈] [R][dK][ be the unit]

_[K]_ 2
min **_α[T]j_** **_[x][φ][′][(][w]j[T]_** **_[x][)]_** ≳ _ρ(σ),_ (79)
_∥α∥2=1_ [E][x][∼N][ (0][,σ][2][)] _j=1_
 X 

_where ρ(σ) is defined in Definition 3._

_Proof of Lemma 1. Let λmax(W ) and λmin(W ) denote the largest and smallest eigenvalues of_
_∇[2]f_ (W ; p) at point W, respectively. Then, from Lemma 4, we have

_λmax(W )_ _λmax(W_ [[][p][]]) + _f_ (W ; p) _f_ (W [[][p][]]; p) 2,
_≤_ _∥∇[2]_ _−∇[2]_ _∥_ (80)

_λmin(W )_ _λmin(W_ [[][p][]]) _f_ (W ; p) _f_ (W [[][p][]]; p) 2.
_≥_ _−∥∇[2]_ _−∇[2]_ _∥_

Then, we provide the lower bound of the Hessian matrix of the population function at W [[][p][]]. For
any α ∈ R[dK] defined in (19) with ∥α∥2 = 1, we have

min
**_α_** 2=1 **_[α][T][ ∇][2][f]_** [(][W][ [][p][]][;][ p][)][α]
_∥_ _∥_

_[K]_ 2 _[K]_ 2

= [1] min _λEx_ **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** + _λEx_ **_α[T]j_** **_xφ[′](wj[[][p][]][T]_** **_x)_**

_K_ [2] **_α_** 2=1
_∥_ _∥_ _j=1_ _j=1_

h [K]X 2 [e] e X _[K][e]_ e  i 2 (81)

min **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** + min _λEx_ **_α[T]j_** **_xφ[′](wj[[][p][]][T]_** **_x)_**

_≥_ _K[1][2]_ **_α_** 2=1 _[λ][E][x]_ **_α_** 2=1

_∥_ _∥_ _j=1_ _∥_ _∥_ _j=1_
 X  e X 

_λρ(δ[˜])_ e [e] e

_,_

_≥_ _[λρ]11[(][δ][) +]κ[2]γK[ e]_ [2]

where the last inequality comes from Lemma 13.

Next, the upper bound can be bounded as

max
**_α_** 2=1 **_[α][T][ ∇][2][f]_** [(][W][ [][p][]][;][ p][)][α]
_∥_ _∥_

= [1] max _λEx_ _[K]_ **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** 2 + _λEx_ _[K]_ **_α[T]j_** **_xφ[′](wj[[][p][]][T]_** **_x)_** 2

_K_ [2] **_α_** 2=1 (82)
_∥_ _∥_ _j=1_ _j=1_

h  X  e X  i

_[K]_ 2 [e] _[K][e]_ e 2
max **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** + max _λEx_ **_α[T]j_** **_xφ[′](wj[[][p][]][T]_** **_x)_** _._

_≤_ _K[1][2]_ **_α_** 2=1 _[λ][E][x]_ **_α_** 2=1

_∥_ _∥_ _j=1_ _∥_ _∥_ _j=1_
 X  e X 

e [e] e


-----

2
For Ex _Kj=1_ **_[α]j[T]_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_**, we have
 P 

_[K]_ 2
Ex **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_**

_j=1_

 X 


**_α[T]j1_** **_[x][φ][′][(][w]j[[][p]1[]][T]_** **_x)α[T]j2_** **_[x][φ][′][(][w]j[[][p]2[]][T]_** **_x)_**

_j1=1_ _j2=1_

X X


=Ex


Exα[T]j1 **_[x][φ][′][(][w]j[[][p]1[]][T]_** **_x)α[T]j2_** **_[x][φ][′][(][w]j[[][p]2[]][T]_** **_x)_**
_j2=1_

X


_j1=1_

_K_

_j1=1_

X

_K_

_j1=1_

X


Ex(α[T]j1 **_[x][)][4][E][x][(][φ][′][(][w]j[[][p]1[]][T]_** **_x))[4]Ex(α[T]j2_** **_[x][)][4][E][x][(][φ][′][(][w]j[[][p]2[]][T]_** **_x))[4][i][1][/][4]_**


(83)

(84)


_j2=1_


3δ[2] **_αj1_** 2 **_αj2_** 2
_∥_ _∥_ _∥_ _∥_
_j2=1_

X


_≤6δ[2]_


1
2 [+][ ∥][α][j]2 _[∥][2]2[)]_
2 [(][∥][α][j][1] _[∥][2]_


_j1=1_ _j2=1_


=6Kδ[2]

Therefore, we have

max
**_α_** 2=1 **_[α][T][ ∇][2][f]_** [(][W][ [][p][]][;][ p][)][α]
_∥_ _∥_

_[K]_ 2 _[K]_ 2
max **_α[T]j_** **_[x][φ][′][(][w]j[[][p][]][T]_** **_x)_** + max _λEx_ **_α[T]j_** **_xφ[′](wj[[][p][]][T]_** **_x)_**

_≤_ _K[1][2]_ **_α_** 2=1 _[λ][E][x]_ **_α_** 2=1

_∥_ _∥_ _j=1_ _∥_ _∥_ _j=1_
 X  e X 

_λδ[˜][2])_ e [e] e

_._

_≤_ [6(][λδ][2]K[ +][ e]

Then, given (20), we have


_∥W_ [(0][,][0)] _−_ **_W_** [[][p][]]∥F = p∥W [(0][,][0)] _−_ **_W_** _[∗]∥F ≲_ _µ[σ][2][K]K [.]_ (85)

Combining (85) and Lemma 12, we have


_λρ(δ[˜])_
_f_ (W ; p) _f_ (W [[][p][]]; p) 2 ≲ _[λρ][(][δ][) +][ e]_ _._ (86)
_∥∇[2]_ _−∇[2]_ _∥_ 132κ[2]γK [2]

Therefore, (86) and (80) completes the whole proof.

H.2 PROOF OF LEMMA 2

The task of bounding of the quantity between ∥∇f[ˆ] −∇f _∥2 is dividing into bounding I1, I2, I3 and_
_I4 as shown in (89). I1 and I3 represent the deviation of the mean of several random variables to_
their expectation, which can be bounded through concentration inequality, i.e, Chernoff bound. I2
and I4 come from the inconsistency of the output label y and pseudo label _y in the empirical risk_
function in (1) and population risk function in (17). The major challenge lies in characterizing the
upper bound of I2 and I4 as the linear function of **_W −W_** [[][p][]] and W [[][p][]] _−W_ _[∗] e, which is summarized_
in (96).

[f]


-----

_Proof of Lemma 2. From (1), we know that_


_N_ 1

_K_

_n=1_

X 


1

_K_




_∂f[ˆ]_

(W ) = _[λ]_
_∂wk_ _N_


_K_

_φ(wj[T]_ **_[x][n][)][ −]_** _[y][n]_ **_xn + [1][ −]_** _[λ]_

_M_

_j=1_

X 


_φ(wj[T]_ **_xm)_** _yn_ **_xm_**
_−_
_j=1_

X 

[e] e e


_m=1_


_φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn_**



_K_ [2]N


_n=1_ _j=1_


+ [1][ −] _[λ]_

_K_ [2]M


+ K[1][ −][2]M[λ] _φ(wj[T]_ **_xm) −_** _φ(wj[T]_ **_xm)_** **_xm._**

_m=1_ _j=1_

X X  

(87)

[e] e [e] e

From (32), we know that

_K_ _K_

_∂f[ˆ]_

(W ) = _[λ]_ _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][)]_** **_x + [1][ −]_** _[λ]_ **_x_** _φ(wj[T]_ **_x)_** _φ(wj[T]_ **_x)_** **_x._**
_∂wk_ _K_ [2][ E][x] _K_ [2][ E][e] _−_

_j=1_ _j=1_

X   X  

(88)

[e] e [e] e

Then, from (17), we have


_∂f[ˆ]_

(W ) = _[λ]_
_∂wk_ _K_ [2][ E][x]


_∂f[ˆ]_

(W ) (W ; p)
_∂wk_ _−_ _∂[∂f]wk_


_φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn −_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_**
  


_K_ [2]N


_j=1_


_n=1_


_K_ _M_

+ K[1][ −][2]M[λ] _j=1_ _m=1_ _φ(wj[T]_ **_xm) −_** _φ(wj[T]_ **_xm)_** **_xm −_** Ex _φ(wj[T]_ **_x) −_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**

X h X   e  i

_K_ _N_

1 [e] e [e] e [e] e e

= _[λ]_ _φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][)]_** **_x_**

_K_ [2] _j=1_ _N_ _n=1_ _−_ (89)

X h X       i

_K_

+ _[λ]_ Ex _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_**

_K_ [2]

_j=1_

X h   i

_K_ 1 _M_

+ [1]K[ −][2][λ] _j=1_ _M_ _m=1_ _φ(wj[T]_ **_xm) −_** _φ(wj[T]_ **_xm)_** **_xm −_** Ex _φ(wj[T]_ **_x) −_** _φ(wj[T]_ **_x)_** **_x_**

X h X   e  i

_K_

[e] e [e] e [e] e [e] e

+ [1]K[ −][2][λ] Ex _φ(wj[T]_ **_x) −_** _φ(wj[[][p][]][T]_ (p)x) **_x_**

_j=1_

X eh  i

:=I1 + I2 + I3 + I4. e [e] e e

For any αj ∈ R[d] with ∥αj∥2 ≤ 1, we define a random variable Z(j) = _φ(wj[T]_ **_[x][)][−][φ][(][w]j[∗][T]_** **_[x][)]_** **_α[T]j_** **_[x]_**
and Zn(j) = _φ(wj[T]_ **_[x][n][)]_** _[−]_ _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_α[T]j_** **_[x][n][ as the realization of][ Z][(][j][)] [ for][ n][ = 1][,][ 2][ · · ·][, N]_** [. Then,]
for any p N[+], we have
_∈_   
E _Z_ = E _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][)][|][p][ · |][α]j[T]_** **_[x][|][p][][1][/p]_**
_|_ _|[p][][1][/p]_ _|_
   (90)

E (wj **_wj[∗][)][T][ x][|][p][ · |][α]j[T]_** **_[x][|][p][][1][/p]_**
_≤_ _|_ _−_


_C_ _δ[2]_ **_wj_** **_wj[∗]_**
_≤_ _·_ _∥_ _−_ _[∥][2]_ _[·][ p,]_

where C is a positive constant and the last inequality holds since x ∼N (0, δ[2]). From Definition 2,
by Chernoff inequality, we havewe know that Z belongs to sub-exponential distribution with ∥Z∥ψ1 ≲ _δ[2]∥wj −_ **_wj[∗][∥][2][. Therefore,]_**

_N_

_j_

_[∥][2][)][2][·][Ns][2]_

P [1] _Zn(j)_ EZ(j) _< t_ 1 (91)

_N_ _−_ _≤_ _−_ _[e][−][C][(][δ][2][∥][w]e[j][Nst][−][w][∗]_

 _nX=1_ 


-----

for some positive constant C and any s ∈ R.


Let t = δ[2] **_wj_** **_wj[∗]_**
_∥_ _−_ _[∥][2]_


_d log q_


and s =


2

_Cδ[2]_ **_wj_** **_wj[∗]_**
_∥_ _−_ _[∥][2][ ·][ t][ for some large constant][ q >][ 0][, we have]_


_d log q_



[1] _Zn(j)_ EZ(j) ≲ _δ[2]_ **_wj_** **_wj[∗]_**

_N_ _n=1_ _−_ _∥_ _−_ _[∥][2]_ _[·]_

X

with probability at least 1 − _q[−][d]. From Lemma 7, we have_


(92)

(93)


_φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn −_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][)]_**
  


_n=1_


_d log q_


2δ[2] **_wj_** **_wj[∗]_**
_≤_ _∥_ _−_ _[∥][2]_ _[·]_


with probability at least 1 − (q/5)[−][d]. Since q is a large constant, we release the probability as
1 − _q[−][d]_ for simplification. Similar to Z, we have


_M_

_M[1]_ _m=1_ _φ(wj[T]_ **_xm) −_** _φ(wj[T]_ **_xm)_** **_xm −_** Ex _φ(wj[T]_ **_x) −_** _φ(wj[T]_ **_x)_** **_x_**

X   e 

[e] _d log q_ e [e] e [e] e [e] e

≲δ[˜][2] **_wj_** **_wj_** 2
_∥_ _−_ _∥_ _·_ r _M_

with probability at least 1e _q[−][d]._
_−_

|II 𝜃𝜃 1 IV-A|I 𝒘∗𝒘 𝑗𝑗 𝜃 1𝜃 𝒘 𝑗[𝒘 𝑗𝑝]𝑝|
|---|---|
||III|



Figure 13: The subspace spanned by wj[∗] [and][ w]j[[][p][]]


(94)


For term Ex _φ(wj[∗][T]_ **_[x][)][−][φ][(][w]j[[][p][]][T]_** **_x)_** **_x_**, let us define the angle between wj[∗] [and][ w]j[[][p][]] as θ1. Figure
13 shows the subspace spanned by the vectorh   i **_wj[∗]_** [and][ e]wj. We divide the subspace by 4 pieces, where
the gray region denotes area I, and the blue area denotes area II. Areas III and IV are the symmetries
of II and I from the origin, respectively. Hence, we have

Ex _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_**

=Exh area I _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]ix)_ **_x_** + Ex area II _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_**
_∈_ _∈_

+ Ex area IIIh  _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_xi)_** **_x_** + Ex area IVh  _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_xi)_** **_x_**
_∈_ _∈_

(95)

=Ex area I _φ(h wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_** + Ei **_x_** area II **_wj[∗][T]h xx_** Ex area III **_wj[[][p][]][T]_** **_xx_** i
_∈_ _∈_ _−_ _∈_

=Ex∈ area Ih (wj[∗] _j_ [)][T][ xx] + Ex∈area IIi (wj[∗] _j_ [)][T][ xx]e e  

_[−]_ **_[w][[][p][]]_** _[−]_ **_[w][[][p][]]_**

= [1] (wj[∗] _j_ [)][T][ xx]   

2 [E][x] _[−]_ **_[w][[][p][]]_**
 


-----

Therefore, we have

_λ_

_φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_** + [1][ −] _[λ]_ **_x_** _φ(wj[T]_ **_x)_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**
_K_ [2][ E][x] _K_ [2][ E][e] _−_ 2

_λ_ h   i h  i
= (wj[∗] _j_ [)][T][ xx] + [1][ −] _[λ]_ **_x_** (wj **_wj[[][p][]][)][T] e[ xx][e]_** e e (96)

2K [2][ E][x] _[−]_ **_[w][[][p][]]_** 2K [2][ E][e] _−_ 2
   

_λδ[2]_ **_wj_** **_wj[[][p][]]_** + (1 _λ)δ[˜][2]_ **_wj[∗]_** ej 2

= _·_ _−_ _−_ _·_ _[−]_ **_[w][[][p][]]_** _._

2K [2]

From (93), (94) and (96), we have  e    

_f_

_[∂]_ [ˆ] (W ; p) (W )

_∂wk_ _−_ _∂[∂f]wk_ 2

_K_ _N_

[1] _φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][)]_** **_x_**

_≤_ _K[λ][2]_ _j=1_ _N_ _n=1_ _−_ 2

X X      

_K_ _M_

+ [1][ −] _[λ]_ [1] _φ(wj[T]_ **_xm)_** _φ(wj[T]_ **_xm)_** **_xm_** Ex _φ(wj[T]_ **_x)_** _φ(wj[T]_ **_x)_** **_x_**

_K_ [2] _j=1_ _M_ _m=1_ _−_ _−_ _−_ 2

X X   e 

_K_

_λ_ [e] e [e] e [e] e [e] e

+ _φ(wj[∗][T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_** + [1][ −] _[λ]_ **_x_** _φ(wj[T]_ **_x)_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**

_j=1_ _K_ [2][ E][x] _K_ [2][ E][e] _−_ 2 (97)

X h   i h  i

_K_ _K_

_d log q_ _d log q_ e [e] e e

_≤_ _K[λ][2][ δ][2]r_ _N_ _·_ _j=1_ _∥wj −_ **_wj[∗][∥][2]_** [+ 1]K[ −][2][λ] _·_ _δ[˜][2]r_ _M_ _·_ _j=1_ _∥wj −_ **_wj∥2_**

X X

_K_

1 e
+ 2K [2][ ·] _j=1_ _λδ[2]_ _·_ **_wj −_** **_wj[[][p][]]_** + _λδ[˜][2]_ _·_ **_wj[∗]_** _[−]_ **_[w]j[[][p][]]_** 2

_λ_ Xd log q   e  [e]   _d log q_
_≤_ _K_ [3][/][2][ δ][2] _N_ _· ∥W −_ **_W_** _[∗]∥2 + [1]K[ −][3][/][λ][2][ ·][ ˜]δ[2]_ _M_ _· ∥W −_ **_W[f] ∥2_**

r r

1
+ _λδ[2]_ **_W_** **_W_** [[][p][]][] + (1 _λ)δ[˜][2]_ **_W_** **_W_** [[][p][]][]

2K [3][/][2] _·_ _−_ _−_ _·_ _[∗]_ _−_ 2
 

with probability at least f 1 _q[−][d]._
_−_

In conclusion, let α ∈ R[Kd] and αj ∈ R[d] with α = [α[T]1 _[,][ α]2[T]_ _[,][ · · ·][,][ α]K[T]_ []][T][, we have]

_∥∇f_ (W ) −∇f[ˆ](W )∥2 = **_α[T][  ]∇f_** (W ) −∇f[ˆ](W )

_K_



_∂f[ˆ]_

_≤_ **_α[T]k_** _∂wk_ (W ) − _∂[∂f]wk_ (W )

_k=1_

X   

_K_

_f_

≲ _[∂]_ [ˆ] (W ) (W )

_∂wk_ _−_ _∂[∂f]wk_ 2

_k=1_ _[· ∥][α][k][∥][2]_

X

_d log q_ _d log q_

≲ _K [λ]_ _[δ][2]_ _N_ _· ∥W −_ **_W_** _[∗]∥2 + [1][ −]K_ _[λ]_ _·_ _δ[˜][2]_ _M_ _· ∥W −_ **_W[f] ∥2_**

r r

1
+ _λδ[2]_ **_W_** **_W_** [[][p][]][] + (1 _λ)δ[˜][2]_ **_W_** **_W_** [[][p][]][]

2K _·_ _−_ _−_ _·_ _[∗]_ _−_ 2

(98)
 f  

with probability at least 1 − _q[−][d]._

H.3 PROOF OF LEMMA 12

The distance of the second order derivatives of the population risk function f (·; p) at point W and
**_W_** [[][p][]] can be converted into bounding P1, P2, P3 and P4, which are defined in (101). The major


-----

idea in proving P1 is to connect the error bound to the angle between W and W [[][p][]]. Similar ideas
apply in bounding the other three items as well.

_Proof of Lemma 12. From (17), we have_

_∂[2]f_

_∂wj1_ _∂wj2_ (W [[][p][]]; p) = _K[λ][2][ E][x][φ][′][(][w]j[[][p]1[]][T]_ **_x)φ[′](wj[[][p]2[]][T]_** **_x)xx[T]_** + [1]K[ −][2][λ][ E]x[e][φ][′][(][w]j[[][p]1[]][T] **_x)φ[′](wj[[][p]2[]][T]_** **_x)xx[T]_** _,_

(99)

e e e e


_∂[2]f_
and (W ; p) = _[λ]_ _j1_ **_[x][)][φ][′][(][w]j[T]2_** **_[x][)][xx][T][ + 1][ −]_** _[λ]_ **_x[φ][′][(][w]j[T]1_** **_x)φ[′](wj[T]2_** **_x)xx[T]_** _,_

_∂wj1_ _∂wj2_ _K_ [2][ E][x][φ][′][(][w][T] _K_ [2][ E][e]

(100)

[e] [e] e e

where wj[[][p][]] is the j-th column of W [[][p][]]. Then, we have

_∂[2]f_ _∂[2]f_

_∂wj1_ _∂wj2_ (W _[∗]) −_ _∂wj1_ _∂wj2_ (W )


= _[λ]_

_K_ [2][ E][x]


_φ[′](wj[[][p]1[]][T]_ **_x)φ[′](wj[[][p]2[]][T]_** **_x)_** _φ[′](wj[T]1_ **_[x][)][φ][′][(][w]j[T]2_** **_[x][)]_** **_xx[T]_**
_−_
i


+ [1]K[ −][2][λ][ E]x[e] _φ[′](wj[[][p]1[]][T]_ **_x)φ[′](wj[[][p]2[]][T]_** **_x) −_** _φ[′](wj[T]1_ **_x)φ[′](wj[T]2_** **_x)_** **_xx[T]_**

h i

= _[λ]_ _φ[′](wj[[][p]1[]][T]_ **_x)_** _φ[′]e(wj[[][p]2[]][T]_ **_x)_** eφ[′](wj[T]2 **_[x][)]_** + φ[′](wj[T]2 **_[x][)]_** _φe[′]e(wj[[][p]1[]][T]_ **_x)_** _φ[′](wj[T]1_ **_[x][)]_** **_xx[T]_**

_K_ [2][ E][x] _−_ [e] [e] _−_
h      [i]

+ [1]K[ −][2][λ][ E]x[e] _φ[′](wj[[][p]1[]][T]_ **_x)_** _φ[′](wj[[][p]2[]][T]_ **_x) −_** _φ[′](wj[T]2_ **_x)_** + φ[′](wj[T]2 **_x)_** _φ[′](wj[[][p]1[]][T]_ **_x) −_** _φ[′](wj[T]1_ **_x)_** **_xx[T]_**

h      [i]

= _[λ]_ Exφ[′](wj[[][p]1[]][T] **_x)_** _φ[′]e(wj[[][p]2[]][T]_ **_x)_** eφ[′](wj[T]2 **_[x][)]_** **_xx[T]_** + Exφ[′](wj[T]2 **_[x][)]_** _φ[′](wj[[][p]1e[]][T]_ **_x)_** _φ[′](wj[T]1_ **_[x][)]exxe_** _[T][ i]_

_K_ [2] _−_ [e] [e] _−_ [e]

h      

+ [1]K[ −][2][λ] Ex[φ][′][(][w]j[[][p]1[]][T] **_x)_** _φ[′](wj[[][p]2[]][T]_ **_x) −_** _φ[′](wj[T]2_ **_x)_** **_xx[T]_** + Ex[φ][′][(][w]j[T]2 **_x)_** _φ[′](wj[[][p]1[]][T]_ **_x) −_** _φ[′](wj[T]1_ **_x)_** **_xx[T][ i]_**

h e   e  

:= _K[λ][2][ (][P][1][ +][ P][2][) + 1]K[ −][2][λ][ (]e_ **_[P][3][ +][ P][4][)][.]e_** [e] e e [e] e [e] e e

(101)

For any a ∈ R[d] with ∥a∥2 = 1, we have

**_a[T]_** **_P1a =Exφ[′](wj[[][p]1[]][T]_** **_x)_** _φ[′](wj[[][p]2[]][T]_ **_x)_** _φ[′](wj[T]2_ **_[x][)]_** (a[T] **_x)[2]_** (102)
_−_

where a R[d]. Let I = φ[′](wj[[][p]1[]][T] **_x)_** _φ[′](wj[[][p]2[]][T] x)_ _φ[′](wj[T]2_ **_[x][)]_** (a[T] **_x)[2]. It is easy to verify there ex-_**
_∈_ _−_ _·_
ists a group of orthonormal vectors such that  _B = {a, b, c, a[⊥]4[,][ · · ·][,][ a]d[⊥][}][ with][ {][a][,][ b][,][ c][}][ spans a sub-]T_

space that contains a, wj2 and wj[∗]2 [. Then, for any][ x][, we have a unique][ z][ =] _z1,_ _z2,_ _· · ·,_ _zd_

such that h i
**_x = z1a + z2b + z3c + · · · + zda[⊥]d_** _[.]_
Also, since x (0, δ[2]Id), we have z (0, δ[2]Id). Then, we have
_∼N_ _∼N_

_I =Ez1,z2,z3_ _φ[′][ ]wj[T]2_ **_[x]_** _φ[′][ ]wj[[][p]2[]][T]_ **_x_** **_a[T]_** **_x_**
_|_ _−_ _| · |_ _|[2]_

= _φ[′][ ]wj[T]2_ **_[x]_** _φ[′][ ]wj[[][p]2[]][T]_ **_x_** **_a[T]_** **_x_** _fZ(z1, z2, z3)dz1dz2dz3,_
_|_ _−_ _| · |_ _|[2]_ _·_
Z

where x = z1a + z2b + z3c and _fZ(z1, z2, z3) is probability density function of (z1, z2, z3). Next,_
we consider spherical coordinates with z1 = Rcosφ1, z2 = Rsinφ1sinφ2, z3 = Rsinφ1cosφ2.
Hence,

_I =_ _φ[′][ ]wj[T]2_ **_[x]_** _φ[′][ ]wj[[][p]2[]][T]_ **_x_** _R cos φ1_ _fZ(R, φ1, φ2)R[2]_ sin φ1dRdφ1dφ2. (103)
_|_ _−_ _| · |_ _|[2]_ _·_
Z
 

It is easy to verify that φ[′][ ]wj[T]2 **_[x]_** only depends on the direction of x and

_fZ(R, φ1, φ2) =_ 1 3 _z1[2]_ [+]2[z]δ2[2][2][+][z]3[2] = 1 3 2δ[2]

(2πδ[2]) 2 _[e][−]_ (2πδ[2]) 2 _[e][−]_ _[R][2]_


-----

only depends on R. Then, we have

_I(i2, j2)_

= _φ[′][ ]wj[T]2_ [(][x][/R][)] _φ[′][ ]wj[[][p]2[]][T]_ (x/R) _R cos φ1_ _fZ(R)R[2]_ sin φ1dRdφ1dφ2
_|_ _−_ _| · |_ _|[2]_ _·_
Z ∞  _π_ 2π 

= _R[4]fz(R)dR_ cos φ1 sin φ1 _φ[′][ ]wj[T]2_ [(][x][/R][)] _φ[′][ ]wj[[][p]2[]][T]_ (x/R) _dφ1dφ2_

0 0 0 _|_ _|[2]_ _·_ _· |_ _−_ _|_

Z Z Z

(a) _∞_ _π_ 2π  
3δ[2] _R[2]fz(R)dR_ sin φ1 _φ[′][ ]wj[T]2_ [(][x][/R][)] _φ[′][ ]wj[[][p]2[]][T]_ (x/R) _dφ1dφ2_
_≤_ _·_ 0 0 0 _· |_ _−_ _|_
Z Z Z

 

=3δ[2] Ez1,z2,z3 _φ[′][ ]wj[T]2_ **_[x]_** _φ[′][ ]wj[[][p]2[]][T]_ **_x_**

_·_ _−_ _|_

3δ[2] Ex _φ[′][ ]wj[T]2_ **_[x]_** _φ[′][ ]wj[[][p]2[]][T]_ **_x_** _,_ 
_≤_ _·_ _−_ _|_
(104)
 

where the inequality (a) is derived from the fact that _cosφ1_ 1 and
_|_ _| ≤_
_∞_ 1 _∞_

_R[4]_ 3 2δ[2] _dR =_ 3 2δ[2] )
0 (2πδ[2]) 2 _[e][−]_ _[R][2]_ 0 _−_ (2[R]πδ[3][δ][2][2]) 2 _[d][(][e][−]_ _[R][2]_

Z Z

_∞_
= _e[−]_ 2[R]δ[2][2] _d [R][3][δ][2]_ 3 (105)

0 (2πδ[2]) 2

Z

_∞_ 1
=3δ[2] _R[2]_ 3 2δ[2] _dR._

0 (2πδ[2]) 2 _[e][−]_ _[R][2]_

Z

Define a set 1 = **_x_** (wj[[][p]2[]][T] **_x)(wj[T]2_** **_[x][)][ <][ 0][}][. If][ x][ ∈A][1][, then][ w]j[[][p]2[]][T]_** **_x and wj[T]2_** **_[x][ have different]_**
_A_ _{_ _|_

thatsigns, which means the value of φ[′](wj[T]2 **_[x][)][ and][ φ][′][(][w]j[[][p]2[]][T]_** **_x) are different. This is equivalent to say_**

_|φ[′](wj[T]2_ **_[x][)][ −]_** _[φ][′][(][w]j[[][p]2[]][T]_ **_x)| =_** 10,, if if x x ∈A11 _._ (106)
 _∈A[c]_

Moreover, if x 1, then we have
_∈A_

**_wj[[][p]2[]][T]_** **_x_** **_wj[[][p]2[]][T]_** **_x_** **_wj[T]2_** **_[x][| ≤∥][w]j[[][p]2[]]_** 2 _[∥][2][ · ∥][x][∥][2][.]_ (107)
_|_ _| ≤|_ _−_ _[−]_ **_[w][j]_**

Let us define a set A2 such that

**_wj[[][p]2[]][T]_** **_x_** _j2_ 2 _[∥][2]_ **_wj[[][p]2[]]_** 2 _[∥][2]_
_A2 =nx_ _∥w|_ _j[∗]2_ _[∥][2][∥][x]|[∥][2]_ _≤_ _[∥][w][∗]∥w[−]j[∗]2[w][∥][2][j]_ o = nθx,wj[∗]2 _| cos θx,wj[p2]_ _[| ≤]_ _∥_ _∥w[−]j[[][p]2[]][w][∥][2][j]_ o. (108)

Hence, we have that

Ex _φ[′](wj[T]2_ **_[x][)][ −]_** _[φ][′][(][w]j[[][p]2[]][T]_ **_x)_** =Ex _φ[′](wj[T]2_ **_[x][)][ −]_** _[φ][′][(][w]j[[][p]2[]][T]_ **_x)_**
_|_ _|[2]_ _|_ _|_

=Prob(x 1) (109)
_∈A_
Prob(x 2).
_≤_ _∈A_

Since x ∼N (0, δ[2]∥a∥2[2][I][)][,][ θ]x,wj[[][p]2[]] [belongs to the uniform distribution on][ [][−][π, π][]][, we have]

_π_ arccos _∥wj[[][p]2[]][−][w][j]2_ _[∥][2]_
Prob(x 2) = _−_ _∥wj[[][p]2[]][∥][2]_ _∥wj[[][p]2[]]_ _[−]_ **_[w][j]2_** _[∥][2]_ )
_∈A_ _π_ _≤_ _π[1]_ [tan(][π][ −] [arccos] **_wj[[][p]2[]]_**

_∥_ _[∥][2]_

= [1] _∥wj[[][p]2[]]_ _[−]_ **_[w][j]2_** _[∥][2]_ ) (110)

_π_ [cot(arccos] **_wj[[][p]2[]]_**

_∥_ _[∥][2]_

**_wj[[][p]2[]]_** 2 _[∥][2]_
_∥_ _[−]_ **_[w][j]_** _._

_≤_ _π[2]_ **_wj[[][p]2[]]_**

_∥_ _[∥][2]_


-----

Hence, (104) and (110) suggest that

_I_
_≤_ [6]π[δ][2]


**_wj2_** **_wj[[][p]2[]]_**
_∥_ _−_ _[∥][2]_ **_a_** 2[.] (111)

_σK_ _· ∥_ _∥[2]_


The same bound that shown in (111) holds for P2 as well.

**_P3 and P4 satisfy (111) except for changing δ[2]_** to _δ[˜][2]._

Therefore, we have

_f_ (W [[][p][]]; p) _f_ (W ; p) 2
_∥∇[2]_ _−∇[2]_ _∥_

= max **_α[T]_** ( _f_ (W [[][p][]]; p) _f_ (W ; p))α
**_α_** 2 1 _∇[2]_ _−∇[2]_
_∥_ _∥_ _≤_

_K_ _K_

_∂[2]f_ _∂[2]f_

_≤_ _j1=1_ _j2=1_ _j1_  _∂wj1_ _∂wj2_ (W [[][p][]]; p) − _∂wj1_ _∂wj2_ (W ; p)αj2

X X

_K_ _K_

**_[α][T]_** _λ_ **_P1 + P2_** 2 + (1 _λ)_ **_P3 + P4_** 2 **_αj1_** 2 **_αj2_** 2

_≤_ _K[1][2]_ _∥_ _∥_ _−_ _∥_ _∥_ _∥_ _∥_ _∥_ _∥_

_j1=1_ _j2=1_

X X  

_K_ _K_ **_wj[[][p]2[]]_** 2 _[∥][2]_

4(λδ[2] + (1 _λ)δ[˜][2])_ _∥_ _[−]_ **_[w][j]_** **_αj1_** 2 **_αj2_** 2

_≤_ _K[1][2]_ _−_ _σK_ _∥_ _∥_ _∥_ _∥_

_j1=1_ _j2=1_

X X

_λδ[2]_ + (1 _λ)δ[˜][2][]_ _,_

_≤_ _K[4]_ _−_ _· [∥][W][ [][p]σ[]][ −]K_ **_[W][ ∥][2]_**

 

where α ∈ R[Kd] and αj ∈ R[d] with α = [α[T]1 _[,][ α]2[T]_ _[,][ · · ·][,][ α]K[T]_ []][T][ .]


(112)


I INITIALIZATION VIA TENSOR METHOD

In this section, we briefly summarize the tensor initialization in (Zhong et al., 2017) by studying the
target function class as


_y = [1]_


_vj[∗][φ][(][w]j[∗][T]_ **_[x][)][,]_** (113)
_j=1_

X


whereWithout loss of generalization, we can assume vj[∗] _[∈]_ _[R][. Note that for ReLU function, we have] vj[∗]_ _[ v]j[∗][φ][(][w]j[∗][T]_ **_[x][) =][ sign][(][v]j[∗][)][φ][(][|][v]j[∗][|][w]j[∗][T]_** **_[x][)][.]_**
function studied in (2) is the special case of (113) when[∈{] v[+1]j[∗] _[,][= 1][ −][1][}][ for all][. Additionally, it is clear that the][ j][. In addition, Theorem 5.6]_
in (Zhong et al., 2017) show that the sign of vj[∗] [can be directly recovered using tensor initialization,]
which indicates the the equivalence of (2) and (113) when using tensor initialization.

We first define some high order momenta in the following way:

**_M1 = Ex{yx} ∈_** R[d], (114)

**_M2 = Ex_** _y_ **_x ⊗_** **_x −_** _δ[2]I_ _∈_ R[d][×][d], (115)
h   [i]

**_M3 = Ex_** _y_ **_x[⊗][3]_** _−_ **_x⊗[e]_** _δ[2]I_ _∈_ R[d][×][d][×][d], (116)

where Ex is the expectation over x andh z [⊗][3] := z ⊗ **_z ⊗z[i]. The operator_** _⊗_ is defined as

_d2_

**_v⊗[e]_** **_Z =_** _i=1(v ⊗_ **_zi ⊗_** **_zi + zi ⊗_** **_v ⊗_** **_zi + zi ⊗_** **_zi ⊗[e]v),_** (117)

X

for any vector v ∈ R[d][1] and Z ∈ R[d][1][×][d][2] .


-----

Following the same calculation formulas in the Claim 5.2 (Zhong et al., 2017), there exist some
known constants ψi, i = 1, 2, 3, such that


_ψ1_ **_wj[∗]_** _j_ _[,]_ (118)
_j=1_ _· ∥_ _[∥][2]_ _[·][ w][∗]_

X


**_M1 =_**


_j=1_ _ψ2 · ∥wj[∗][∥][2]_ _[·][ w]j[∗][w][∗]j_ _[T]_ _[,]_ (119)

X


**_M2 =_**


_ψ3_ **_wj[∗]_** _j_ _,_ (120)
_j=1_ _· ∥_ _[∥][2]_ _[·][ w][∗⊗][3]_

X


**_M3 =_**


where w[∗]j [=][ w]j[∗][/][∥][w]j[∗][∥][2][ in (114)-(116) is the normalization of][ w]j[∗][. Therefore, we can see that the]
information of **_wj[∗]_** _j=1_ [are separated as the direction of][ w][j][ and the magnitude of][ w][j][ in][ M][1][,][ M][2]
and M3. _{_ _[}][K]_

_N_
**_M1, M2 and M3 can be estimated through the samples_** (xn, yn) _n=1[, and let][ c]M1,_ **_M2,_** **_M3_**
denote the corresponding estimates. First, we will decompose the rank-K tensor M3 and obtain the

**_w[∗]j_** _[}][K]j=1[. By applying the tensor decomposition method (Kuleshov et al., 2015) to][ c]M3, the outputs,[c]_ [c]
_{_

denoted by **_w∗j_** [, are the estimations of][ {][s][j][w][∗]j _[}][K]j=1[, where][ s][j][ is an unknown sign. Second, we will]_
estimate sj, vj[∗] [and][ ∥][w]j[∗][∥][2][ through][ M][1][ and][ M][2][. Note that][ M][2][ does not contain the information of]
**_sj because s[b][2]j_** [is always][ 1][. Then, through solving the following two optimization problem:]


**_α1 = arg min_** **_M1_** _ψ1α1,jw∗j_ _,_
**_α1∈R[K][ :]_** _−_ _j=1_

X

_K_

**_α2b = arg min_** **_M2[c]_** _ψ2α2,jw∗j[b]w∗j_ _T_
**_α2∈R[K][ :]_** _−_ _j=1_

X

The estimation of sj can be given asb [c] [b] [b]

_sˆj = sign(α1,j/α2,j)._

Also, we know that _α1,j_ is the estimation of **_wj[∗]_**
_|_ _|_ _∥_ b[∥] [and]b

_vˆj = sign(α1,j/sj) = sign(α2,j)._

b

Thus, W [(0)] is given as

b b

sign(α2,1)α1,1w∗1[,] _,_ sign(α2,K)α1,Kw∗K

_· · ·_
h
b b [b] b b [b]

**Subroutine 1 Tensor Initialization Method**


(121)


1: Input: labeled data D = {(xn, yn)}n[N]=1[;]

2: Partition into three disjoint subsets 1, 2, 3;
_D_ _D_ _D_ _D_
3: Calculate **_M1,_** **_M2 following (114), (115) using D1, D2, respectively;_**

4: Obtain the estimate subspace **_V of_** **_M2;_**

5: Calculate **_M[c]3(V[c],_** **_V,_** **_V ) through_** 3;
_D_

6: Obtain {sj}j[K]=1 [via tensor decomposition method (Kuleshov et al., 2015) on][b] [c] [ c]M3(V, **_V,_** **_V );_**

7: Obtain **_α1,[c]α2 by solving optimization problem (121);[b]_** [b] [b]

8: Return: wb _j[(0)]_ = sign(α2,j)α1,jV **_uj and vj[(0)]_** = sign(α2,j), j = 1, ..., K. [b] [b] [b]

b b

To reduce the computational complexity of tensor decomposition, one can projectb b [b] b b **_M3 to a lower-_**
dimensional tensor (Zhong et al., 2017). The idea is to first estimate the subspace spanned by
**_wj[∗]_** _j=1[, and let][ b]V denote the estimated subspace. Moreover, we have_ [c]
_{_ _[}][K]_

**_M3(V,_** **_V,_** **_V ) = Ex_** _y_ (V _[T]_ **_x)[⊗][3]_** _−_ (V _[T]_ **_x)⊗[e]_** Ex(V _[T]_ **_x)(V_** _[T]_ **_x)[T][ i]_** _∈_ R[K][×][K][×][K], (122)
h  

[b] [b] [b] [b] [b] [b] [b]


-----

Then, one can decompose the estimate **_M3(V,_** **_V,_** **_V ) to obtain unit vectors_** **_sˆj_** _j=1_
_{_ _}[K]_ _[∈]_ [R][K][. Since]

**_w[∗]_** lies in the subspace V, we have V V _[T]_ **_w[∗]j_** [=][ w]j[∗][. Then,][ b]V ˆsj is an estimate of w[∗]j [. The]
initialization process is summarized in Subroutine 1.[c] [b] [b] [b]

J CLASSIFICATION PROBLEMS

The framework in this paper is extendable to binary classification problem. For binary classification
problem, the output y given input x is defined as

Prob{y = 1} = g(W _[∗]; x)_ (123)

with some ground truth parameter W _[∗]. To guarantee the output is within [0, 1], the activation_
function is often used as sigmoid. For classification, the loss function is cross-entropy, and the
objective function over labeled data D is defined as

_f_ (W ) = [1] _yn log g(W ; xn)_ (1 _yn) log(1_ _g(W ; xn))._ (124)
_D_ _N_ _−_ _−_ _−_ _−_

(xnX,yn)∈D

The expectation of objective function can be written as


E _f_ (W ) =E(x,y) _y log(g(W ; xn))_ (1 _y) log(1_ _g(W ; x))_
_D_ _D_ _−_ _−_ _−_ _−_

=ExE(y|x) − _y log(g(W ; xn)) −_ (1 − _y) log(1 −_ _g(W ; x))_ (125)

=Ex _−_ _g(W_ _[∗]; x) log(g(W ; xn)) −_ (1 − _g(W_ _[∗]; x)) log(1 −_ _g(W ; xn))_
h i

Please note that (125) is exactly the same as (32) with λ = 1 when the loss function is squared loss.

For cross entropy loss function, the second order derivative of (125) is calculated as

_∂fD(W )_ = [1] _yn_ 1 − _yn_ _j_ **_[x][)][φ][′][(][w]k[T]_** **_[x][)][xx][T][ .]_** (126)
_∂wj∂wk_ _N_ [[] _g[2](W ; x) [+]_ (1 _g(W ; x))[2][ ]][ ·][ φ][′][(][w][T]_

_−_

when j ̸= k. Refer to (88) in (Fu et al., 2020) or (132) in (Zhang et al., 2020b), we have
_yn(φ[′](wj[T]_ **_[x][)][φ][′][(][w]k[T]_** **_[x][))]_** _φ[′](wj[T]_ **_[x][)][φ][′][(][w]k[T]_** **_[x][)]_**

(127)

_g[2](W ; x)_ 2 _g[2](W ; x)_ 2

_[≤]_ _[≤]_ _[K]_ [2][.]

Following similar steps in (90), from Defintion 2, we know that αj[T] _∂f∂wDj(∂Wwk )_ _[α][k][ belongs to the sub-]_
exponential distribution. Therefore, similiar results for objective function with cross-entropy loss
can be established as well. One can check (Fu et al., 2020) or (Zhang et al., 2020b) for details.

K ONE-HIDDEN LAYER NEURAL NETWORK WITH TOP LAYER WEIGHTS

For a general one-hidden layer neural network, the output of the neural network is defined as


_g(W, v; x) = [1]_


_vjφ(wj[T]_ **_[x][)][,]_** (128)
_j=1_

X


where v = [v1, v2, _, vK]_ _R[K]. Then, the target function can be defined as_
_· · ·_ _∈_


_y = g(W_ _, v[∗]; x) = [1]_

_[∗]_ _K_

for some unknown weights W _[∗]_ and v[∗].


_vj[∗][φ][(][w]j[∗][T]_ **_[x][)]_** (129)
_j=1_

X


In the following paragraphs, we will provide a short description for the equivalence of (129) and (2)
in theoretical analysis. Note that for ReLU functions, we have vjφ(wj[T] **_[x][) =][ sign][(][v][j][)][φ][(][|][v][j][|][w]j[T]_** **_[x][)][.]_**


-----

Without loss of generalization, we can assume vj, vj[∗]
I, we know that the sign of vj[∗] [can exactly estimated through tensor initialization. There, we can][∈{][+1][,][ −][1][}][ for all][ j][ ∈] [[][K][]][5][. From Appendix]
focus on analysis the neural network in the form as


_g(W ; x) = [1]_


_vj[∗][φ][(][w]j[T]_ **_[x][)][.]_** (130)
_j=1_

X


Considering the objective function in (1) and population risk function in (17), we have

_f_

_[∂]_ [ˆ] (W ) (W ; p)

_∂wk_ _−_ _∂[∂f]wk_ 2

_K_ _N_

_λ_
= _vj[∗]_ _φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_**

_K_ [2]N _j=1_ _n=1_ _−_

X h X     


_φ(wj[T]_ **_xm)_** _φ(wj[T]_ **_xm)_** **_xm_** Ex _φ(wj[T]_ **_x)_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**
_−_ _−_ _−_
e 

[e] e [e] e [e] e e

_φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn −_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_**
     


+ K[1][ −][2]M [λ] _[v]j[∗]_

_K_

_vj[∗]_
_j=1_ _·|_ _[| ·]_

X


_j=1_

_λ_

_K_ [2]N


_m=1_

_N_

_n=1_

h X


_M_

+ [1][ −] _[λ]_ _φ(wj[T]_ **_xm)_** _φ(wj[T]_ **_xm)_** **_xm_** Ex _φ(wj[T]_ **_x)_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**

_K_ [2]M _m=1_ _−_ _−_ _−_ 2

_K_ h XN  e  i

_λ_ [e] e [e] e [e] e e

= _φ(wj[T]_ **_[x][n][)][ −]_** _[φ][(][w]j[∗][T]_ **_[x][n][)]_** **_xn_** Ex _φ(wj[T]_ **_[x][)][ −]_** _[φ][(][w]j[[][p][]][T]_ **_x)_** **_x_**

_j=1_ _K_ [2]N _n=1_ _−_

X h X       i

_M_

+ [1][ −] _[λ]_ _φ(wj[T]_ **_xm)_** _φ(wj[T]_ **_xm)_** **_xm_** Ex _φ(wj[T]_ **_x)_** _φ(wj[[][p][]][T]_ **_x)_** **_x_**

_K_ [2]M _m=1_ _−_ _−_ _−_ 2[,]

h X   e  i (131)

[e] e [e] e [e] e e

which is exact the same as (89). Similar results can be derived for Lemma 12. Therefore, the
conclusions and proofs of Lemma 1 and Lemma 2 does not change at all.

Additionally, fixing the second-layer weights and only training the hidden layer is the state-of-theart practice in analyzing two-layer neural networks (Arora et al., 2019b;a; Allen-Zhu et al., 2019;
Safran & Shamir, 2018; Li & Liang, 2018; Brutzkus & Globerson, 2017; Oymak & Soltanolkotabi,
2018; Zhang et al., 2019). Additionally, as indicated in (Safran & Shamir, 2018), training a onehidden-layer neural network with all vj fixed as 1 has intractable many spurious local minima, which
indicates that training problem is not trivial.

the new ground truth weights.5To see this, one can view |vj∗[|][w]j[∗] [as the new ground truth weights, and the goal for this paper is to recover]


-----

